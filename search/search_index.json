{
    "docs": [
        {
            "location": "/", 
            "text": "Getting started\n\n\n\n\nJourneyman is an opinionated CLI tool for Vue.js projects to generate code and automate common tasks.\n\n\n\n\nSimilar to \nLaravel's Artisan\n, \njourneyman\n aims to reduce repetitive programming tasks and make working on Vue.js applications a faster and more pleasant experience, while adhering to Vue.js code style standards and best practices.\n\n\nIsn't this the same thing as \nvue-cli\n?\n\nNo, not quite. Although journeyman provdes some similar features, it doesn't primarily serve to bootstrap the development pipeline but rather to aid a developer during development work. It doesn't care at all what module bundler or linter you use.\n\n\n\n\nActive development:\n Journeyman is being developed currently. The process will be as follows:\n\n\n\n\n\n\n Outline most of the API in this README file, identify design problems beforehand  \n\n\n Write tests for the base console application, build the application from there (TDD style)\n\n\n Write tests for the actual Vue code generation, implement API features from there\n\n\n Write tests for the \nplugin structure\n, implement it from there\n\n\n Refactoring, Optimization, real-world test cases\n\n\n ???\n\n\n PROFIT\n\n\n\n\nInstallation\n\n\nJourneyman should be installed as a global npm module, like so:\n\n\nnpm install --global @radiergummi/journeyman\n\n\n\nPlease note: Journeyman isn't actually available yet, so this package isn't published right now.\n\n\n\n\nJourneyman requires Node.js \n= 8 to run.\n\n\n\n\nUsage\n\n\nJourneyman can be invoked on the command line using the \njourn\n command. Using the \nlist\n command, you can view a list of all available sub-commands that will be detailed in the following sections:\n\n\njourn list\n\n\n\n\nExpected filesystem structure\n\n\nJourneyman assumes your project is set up a certain way by default. This is important because any generated code must be placed in the appropriate directories. While you can configure each path (see the \nconfiguration section\n), the default structure is the best practice all \nvue-cli\n templates follow, for example.\n\nThe below filesystem tree is the structure journeyman expects:\n\n\n\n.                    \n<\n--- Working directory journ is executed in\n\n\u251c\u2500\u2500 build/\n\u251c\u2500\u2500 config/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 assets/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 components/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mixins/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 modules/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 router/\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 styles/\n\u251c\u2500\u2500 static/\n\u251c\u2500\u2500 test/\n\u2514\u2500\u2500 package.json\n\n\n\n\njourn make\n\n\nThe \nmake\n command creates new files on the file system. It allows to bootstrap components, mixins and modules, for example. Use \njourn list make\n to view a list of available boots to strap (heh).\n\n\njourn make component\n\n\nAllows to bootstrap components. The component name passed as the third parameter can be either a filesystem path (\n/foo/bar/MyNewComponent.vue\n), a kebab-case (\nmy-new-component\n) or a CamelCase (\nMyNewComponent\n) name. In each case, the name will be parsed and the file will be generated with the correct format (\nConfig: \npreferred_spelling\n) at the right location (\nConfig: \npaths.components\n)\nGenerated components are described in detail later on.  \n\n\n# Bootstrap a new, empty component\n\njourn make component MyNewComponent\n\n\n# You can use shorthands, too\n\njourn m c MyNewComponent\n\n\n\n\nJourneyman also supports extends and mixins as well as cloning:\n\n\n# New component extending another\n\njourn make component MyOtherComponent --extends MyNewComponent\n\n\n# New component using one or more mixins\n\njourn make component MyOtherComponent --with oneMixin --with anotherMixin\n\n\n# New component based on another\n\njourn make component MyOtherComponent --from MyNewComponent\n\n\n\n\nCloned components will have all properties from the source component but with a new name.\n\n\njourn make mixin\n\n\nAllows to bootstrap mixins.  \n\n\n\n\nTODO HERE\n\n\n\n\njourn make route\n\n\n\n\nTODO HERE\n\n\n\n\njourn make module\n\n\n\n\nTODO HERE\n\n\n\n\njourn make style\n\n\n\n\nTODO HERE\n\n\n\n\njourn extract\n\n\nThe \nextract\n command allows extraction of code into mixins, styles into stylesheets and large templates into individual components.\n\n\n\n\nTODO HERE\n\n\n\n\njourn inline\n\n\nThe exact opposite of the \nextract\n command, \ninline\n allows to inline external code into your components.\n\n\n\n\nTODO HERE\n\n\n\n\njourn lint\n\n\nThe \nlint\n command performs a Vue.js coding style check on your code-base. This allows you to verify all your components adhere to the same style rules. In contrary to \neslint\n for example, This will not check your JS code (there are a lot of perfectly fine tools for this job), but rather verify all your code is streamlined and follows best practices.\n\nThere are a bunch of linting rules available in \nthe configuration\n.\n\n\nAdditionally, if configured so, \nlint\n will check your JSDoc comments to make sure they a) exist, b) are complete and c) are correct. It will also look for repetitions throughout your components which are probably opportunities for mixins.\n\n\njourn config\n\n\nThe \nconfig\n command allows to read and write configuration values.\n\n\njourn config get\n\n\nUse the following command to read the configuration:\n\n\njourn config get \n[\nvalue\n]\n\n\n\n\n\njourn config set\n\n\nUse the following command to set a configuration value:\n\n\njourn config \nset\n \nkey\n \nvalue\n\n\n\n\n\njourn config init\n\n\nUse the following command to write the default configuration values to your \npackage.json\n or \n.journeyman\n file. This way, you've got all available configuration values at hand to modify them to your liking:\n\n\njourn config init \n[\n--package,-p\n]\n \n[\n--dotfile,-d\n]\n\n\n\n\n\nUsing the \n--package\n or \n--dotfile\n parameter, you can optionally specify the target: \npackage.json\n or \n.journeyman\n.\n\nThe default is \n--package\n.\n\n\n\n\nTODO HERE", 
            "title": "Getting started"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Journeyman is an opinionated CLI tool for Vue.js projects to generate code and automate common tasks.   Similar to  Laravel's Artisan ,  journeyman  aims to reduce repetitive programming tasks and make working on Vue.js applications a faster and more pleasant experience, while adhering to Vue.js code style standards and best practices.  Isn't this the same thing as  vue-cli ? \nNo, not quite. Although journeyman provdes some similar features, it doesn't primarily serve to bootstrap the development pipeline but rather to aid a developer during development work. It doesn't care at all what module bundler or linter you use.   Active development:  Journeyman is being developed currently. The process will be as follows:     Outline most of the API in this README file, identify design problems beforehand     Write tests for the base console application, build the application from there (TDD style)   Write tests for the actual Vue code generation, implement API features from there   Write tests for the  plugin structure , implement it from there   Refactoring, Optimization, real-world test cases   ???   PROFIT", 
            "title": "Getting started"
        }, 
        {
            "location": "/#installation", 
            "text": "Journeyman should be installed as a global npm module, like so:  npm install --global @radiergummi/journeyman  Please note: Journeyman isn't actually available yet, so this package isn't published right now.   Journeyman requires Node.js  = 8 to run.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "Journeyman can be invoked on the command line using the  journ  command. Using the  list  command, you can view a list of all available sub-commands that will be detailed in the following sections:  journ list", 
            "title": "Usage"
        }, 
        {
            "location": "/#expected-filesystem-structure", 
            "text": "Journeyman assumes your project is set up a certain way by default. This is important because any generated code must be placed in the appropriate directories. While you can configure each path (see the  configuration section ), the default structure is the best practice all  vue-cli  templates follow, for example. \nThe below filesystem tree is the structure journeyman expects:  \n.                     < --- Working directory journ is executed in \n\u251c\u2500\u2500 build/\n\u251c\u2500\u2500 config/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 assets/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 components/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mixins/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 modules/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 router/\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 styles/\n\u251c\u2500\u2500 static/\n\u251c\u2500\u2500 test/\n\u2514\u2500\u2500 package.json", 
            "title": "Expected filesystem structure"
        }, 
        {
            "location": "/#journ-make", 
            "text": "The  make  command creates new files on the file system. It allows to bootstrap components, mixins and modules, for example. Use  journ list make  to view a list of available boots to strap (heh).", 
            "title": "journ make"
        }, 
        {
            "location": "/#journ-make-component", 
            "text": "Allows to bootstrap components. The component name passed as the third parameter can be either a filesystem path ( /foo/bar/MyNewComponent.vue ), a kebab-case ( my-new-component ) or a CamelCase ( MyNewComponent ) name. In each case, the name will be parsed and the file will be generated with the correct format ( Config:  preferred_spelling ) at the right location ( Config:  paths.components )\nGenerated components are described in detail later on.    # Bootstrap a new, empty component \njourn make component MyNewComponent # You can use shorthands, too \njourn m c MyNewComponent  Journeyman also supports extends and mixins as well as cloning:  # New component extending another \njourn make component MyOtherComponent --extends MyNewComponent # New component using one or more mixins \njourn make component MyOtherComponent --with oneMixin --with anotherMixin # New component based on another \njourn make component MyOtherComponent --from MyNewComponent  Cloned components will have all properties from the source component but with a new name.", 
            "title": "journ make component"
        }, 
        {
            "location": "/#journ-make-mixin", 
            "text": "Allows to bootstrap mixins.     TODO HERE", 
            "title": "journ make mixin"
        }, 
        {
            "location": "/#journ-make-route", 
            "text": "TODO HERE", 
            "title": "journ make route"
        }, 
        {
            "location": "/#journ-make-module", 
            "text": "TODO HERE", 
            "title": "journ make module"
        }, 
        {
            "location": "/#journ-make-style", 
            "text": "TODO HERE", 
            "title": "journ make style"
        }, 
        {
            "location": "/#journ-extract", 
            "text": "The  extract  command allows extraction of code into mixins, styles into stylesheets and large templates into individual components.   TODO HERE", 
            "title": "journ extract"
        }, 
        {
            "location": "/#journ-inline", 
            "text": "The exact opposite of the  extract  command,  inline  allows to inline external code into your components.   TODO HERE", 
            "title": "journ inline"
        }, 
        {
            "location": "/#journ-lint", 
            "text": "The  lint  command performs a Vue.js coding style check on your code-base. This allows you to verify all your components adhere to the same style rules. In contrary to  eslint  for example, This will not check your JS code (there are a lot of perfectly fine tools for this job), but rather verify all your code is streamlined and follows best practices. \nThere are a bunch of linting rules available in  the configuration .  Additionally, if configured so,  lint  will check your JSDoc comments to make sure they a) exist, b) are complete and c) are correct. It will also look for repetitions throughout your components which are probably opportunities for mixins.", 
            "title": "journ lint"
        }, 
        {
            "location": "/#journ-config", 
            "text": "The  config  command allows to read and write configuration values.", 
            "title": "journ config"
        }, 
        {
            "location": "/#journ-config-get", 
            "text": "Use the following command to read the configuration:  journ config get  [ value ]", 
            "title": "journ config get"
        }, 
        {
            "location": "/#journ-config-set", 
            "text": "Use the following command to set a configuration value:  journ config  set   key   value", 
            "title": "journ config set"
        }, 
        {
            "location": "/#journ-config-init", 
            "text": "Use the following command to write the default configuration values to your  package.json  or  .journeyman  file. This way, you've got all available configuration values at hand to modify them to your liking:  journ config init  [ --package,-p ]   [ --dotfile,-d ]   Using the  --package  or  --dotfile  parameter, you can optionally specify the target:  package.json  or  .journeyman . \nThe default is  --package .   TODO HERE", 
            "title": "journ config init"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\nJourneyman allows to set some configuration variables to control its behaviour. This configuration can be stored either in a \n.journeyman\n file or directly in the \npackage.json\n below the key \njourneyman\n which is the preferred way (avoids yet \nanother\n dot file in your project).\n\nIn general, it comes with a set of sensible defaults:\n\n\npaths\n\n\nTo set the output paths generated code should be written to, you can set one or more of the following path settings. Each of them will overwrite the default.\n\n\n\n\n\n\n\n\nKey\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nassets\n\n\n./src/assets\n\n\nPath where all assets live\n\n\n\n\n\n\ncomponents\n\n\n./src/components\n\n\nPath where all components (\n.vue\n files) live\n\n\n\n\n\n\nmixins\n\n\n./src/mixins\n\n\nPath where all mixins (\n.js\n files) live\n\n\n\n\n\n\nmodules\n\n\n./src/modules\n\n\nPath where all modules (\n.js\n files, helpers) live\n\n\n\n\n\n\nrouter\n\n\n./src/router\n\n\nPath to the main router file\n\n\n\n\n\n\nstyles\n\n\n./src/styles\n\n\nPath where all stylesheets (\n.css\n/\n.scss\n files) live\n\n\n\n\n\n\nbuild\n\n\n./build\n\n\nPath where the build modules live\n\n\n\n\n\n\nconfig\n\n\n./config\n\n\nPath where the build configuration lives\n\n\n\n\n\n\npublic\n\n\n./public\n\n\nPath where the build is written to\n\n\n\n\n\n\nstatic\n\n\n./static\n\n\nPath where static assets live\n\n\n\n\n\n\n\n\npreferred_spelling\n\n\nThis setting controls how journeyman generates component names and inserts them, for example. This also applies to file names on the file system. There are two options available:\n - \ncamel\n: Names are generated in \nCamelCase\n.\n - \nkebab\n: Names are generated in \nkebab-case\n.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "Journeyman allows to set some configuration variables to control its behaviour. This configuration can be stored either in a  .journeyman  file or directly in the  package.json  below the key  journeyman  which is the preferred way (avoids yet  another  dot file in your project). \nIn general, it comes with a set of sensible defaults:", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#paths", 
            "text": "To set the output paths generated code should be written to, you can set one or more of the following path settings. Each of them will overwrite the default.     Key  Default  Description      assets  ./src/assets  Path where all assets live    components  ./src/components  Path where all components ( .vue  files) live    mixins  ./src/mixins  Path where all mixins ( .js  files) live    modules  ./src/modules  Path where all modules ( .js  files, helpers) live    router  ./src/router  Path to the main router file    styles  ./src/styles  Path where all stylesheets ( .css / .scss  files) live    build  ./build  Path where the build modules live    config  ./config  Path where the build configuration lives    public  ./public  Path where the build is written to    static  ./static  Path where static assets live", 
            "title": "paths"
        }, 
        {
            "location": "/configuration/#preferred_spelling", 
            "text": "This setting controls how journeyman generates component names and inserts them, for example. This also applies to file names on the file system. There are two options available:\n -  camel : Names are generated in  CamelCase .\n -  kebab : Names are generated in  kebab-case .", 
            "title": "preferred_spelling"
        }, 
        {
            "location": "/plugins/", 
            "text": "Plugins\n\n\nJourneyman provides a few ways to add new functionality, that is: To add new, first-class citizen, commands to \njourn\n. In fact, \nall\n integrated commands are actually plugins.\n\nPlugins are special npm packages that must fulfill a few requirements:\n\n\n\n\nTheir package name starts with \njourneyman-plugin-\n:\n\n   This serves to keep the npm namespace clean and make plugins more obvious. I can't stand packages like \nbody-parser\n that are secretly \nexpress.js\n plugins.\n\n\nTheir \npackage.json\n file includes a \njourneyman-plugin\n key:\n\n   This key provides plugin metadata. The available fields are outlined in \nPlugin metadata fields\n\n\nThey export a class (\nnot an instance!\n) from their main module that extends the base plugin:\n\n   Journeyman provides a base class at \nlib/plugins/Plugin\n that all plugins need to inherit from. It provides several methods Journeyman uses to initialize the plugin and work with it's input and output. This frees implementations from caring about API compatibility and implementation details.\n\n\n\n\nBasically, a plugin provides a new subcommand to journeyman that all its methods are grouped below. A simple plugin might look like this:\n\n\nconst\n \n{\n \nPlugin\n \n}\n \n=\n \nrequire\n(\njourneyman\n);\n\n\n\nclass\n \nEchoPlugin\n \nextends\n \nPlugin\n \n{\n\n\n  \n/**\n\n\n   * The static property \nname\n is used as the subcommand namespace for your plugin\n\n\n   */\n\n  \nstatic\n \nget\n \nname\n()\n \n{\n\n    \nreturn\n \necho\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * This is a private method (as far as JS supports it, at least...). It will *not* be visible \n\n\n   * nor accessible from the command line due to the single underscore prefix.\n\n\n   */\n\n  \n_prepareOutput\n(\nstr\n)\n \n{\n\n    \nreturn\n \necho \n \n+\n \nstr\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * This is a public method (no leading underscore). It will be used as a publicly visible command below your\n\n\n   * plugin namespace:\n\n\n   * journ echo foo\n\n\n   */\n\n  \nfoo\n(\napp\n)\n \n{\n\n    \nconst\n \noutput\n \n=\n \nthis\n.\n_prepareOutput\n(\napp\n.\ninput\n.\nargs\n);\n\n\n    \nreturn\n \nPromise\n.\nresolve\n(\noutput\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nOne-Shot plugins\n\n\nIf your plugin only serves a single purpose -- eg. it doesn't need multiple sub-commands -- you can use one-shot plugins. The only difference to ordinary plugins is that they include the special \n__invoke\n method: If a plugin provides it, journeyman assumes the plugin doesn't need a namespace and only has a single, public command, callable as \njourn \nplugin name\n --params\n. If journeyman finds the __invoke method  inside your plugin, it will disregard any other public methods. As ordinary command methods, \n__invoke\n receives the application instance as its only parameter.\n\n\nconst\n \n{\n \nPlugin\n \n}\n \n=\n \nrequire\n(\njourneyman\n);\n\n\n\nclass\n \nFooPlugin\n \nextends\n \nPlugin\n \n{\n\n  \nstatic\n \nget\n \nname\n()\n \n{\n\n    \nreturn\n \nfoo\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * This is a special one: For single-shot plugins, you can use the __invoke method. \n\n\n   */\n\n  \n__invoke\n(\napp\n)\n \n{\n\n    \nconst\n \noutput\n \n=\n \nthis\n.\n_prepareOutput\n(\napp\n.\ninput\n.\nargs\n);\n\n\n    \nreturn\n \nPromise\n.\nresolve\n(\noutput\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nThe \napp\n parameter to your command methods\n\n\napp\n is an object with several well-defined properties revolving around the command execution lifecycle. It contains everything the command will need to carry out its purpose:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\njourneyman\n\n\nJourneyMan\n\n\nThe current \nJourneyMan\n instance.\n\n\n\n\n\n\nenv\n\n\nMap\nk: String, v: String\n\n\nHolds all system environment variables.\n\n\n\n\n\n\ninput\n\n\nInput\n\n\nHolds the command line input object.\n\n\n\n\n\n\noutput\n\n\nOutput\n\n\nHolds the command line output object.\n\n\n\n\n\n\nplugins\n\n\nArray\nPlugin\n\n\nHolds the list of available plugins. Alias to \njourneyman.plugins\n.\n\n\n\n\n\n\ncall(command: String): Promise\n\n\nfunction\n\n\nAllows to call other commands by their full command input string.\n\n\n\n\n\n\n\n\n\n\nMore properties and methods will be added as the development continues.\n\n\n\n\nAdvanced plugins\n\n\nSingle-class and one-shot plugins will be fine for most purposes. But what if you've got actual \nwork\n to do? Fear not, for there's a third structural option: Instead of providing the individual commands as methods on your plugin, you can also provide a list of \nCommand\n instances.\n\nThis provides you with a belly of additional goodies, like automatic help generation, fine-grained parameter and option handling as well as neatly organized code.\n\n\nA plugin using Command instances might look like this:\n\n\nconst\n \n{\n \nPlugin\n \n}\n \n=\n \nrequire\n(\njourneyman\n);\n\n\nconst\n \nFooCommand\n \n=\n \nrequire\n(\n./commands/FooCommand\n);\n\n\nconst\n \nBarCommand\n \n=\n \nrequire\n(\n./commands/BarCommand\n);\n\n\n\nclass\n \nMyAdvancedPlugin\n \nextends\n \nPlugin\n \n{\n\n  \nstatic\n \nget\n \nname\n()\n \n{\n\n    \nreturn\n \nadvanced\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * This overrides the default of an empty array\n\n\n   */\n\n  \nstatic\n \nget\n \ncommands\n()\n \n{\n\n    \nreturn\n \n[\n\n      \nFooCommand\n,\n\n      \nBarCommand\n\n    \n];\n\n  \n}\n\n\n  \n/**\n\n\n   * Of course, you\nre still free to define additional commands using methods\n\n\n   */\n\n  \nbaz\n(\napp\n)\n \n{\n\n    \n// ...\n\n  \n}\n\n\n}\n \n\n\n\n\nA command class for our plugin, say \nFooCommand\n, should be constructed like this:\n\n\nconst\n \n{\n \nCommand\n \n}\n \n=\n \nrequire\n(\njourneyman\n);\n\n\n\nclass\n \nFooCommand\n \nextends\n \nCommand\n \n{\n\n\n  \n/**\n\n\n   * Since we don\nt have a method name at our disposal, we can set it here. If omitted, \n\n\n   * the name will be inferred from the class name ( Class.name.replace(\nCommand\n, \n).toLowerCase() )\n\n\n   */\n\n  \nstatic\n \nget\n \nname\n()\n \n{\n\n    \nreturn\n \nfoo\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * The __configure() method is called on initialization and allows to configure the command (duh)\n\n\n   */\n\n  \n__configure\n()\n \n{\n\n\n    \n// a little Symfony-y\n\n    \nthis\n.\nsetDescription\n(\nCreates a new foo\n);\n\n    \nthis\n.\naddParameter\n(\nname\n,\n \nn\n,\n \nHow to name your foo\n,\n \nCommand\n.\nPARAM_TYPE_STRING\n);\n\n  \n}\n\n\n  \n/**\n\n\n   * The behaviour is the same as with plugin method commands here\n\n\n   */\n\n  \n__invoke\n(\napp\n)\n \n{\n\n    \nreturn\n \nPromise\n.\nresolve\n();\n\n  \n}\n\n\n}\n\n\n\n\n\nThat's a whole slew of new stuff, so be sure to check out the \nCommand documentation\n.\n\n\nProviding new commands for journeyman's existing sub-commands\n\n\nThat's all fine and dandy, but what if you'd like to provide a new \nmake \nsomething\n? For these cases, you can extend the special \nMakePlugin\n class instead of \nPlugin\n. All commands provided in these will be appended to the \nmake\n subcommand. Beneath \nMakePlugin\n, there's also \nLinkPlugin\n, \nServePlugin\n and \nBuildPlugin\n to extend the respective verbs.\n\n\n\n\nMore extend-plugins will be added as the development continues.\n\n\n\n\nPlugin metadata fields\n\n\nThe following \npackage.json\n properties of the \njourneyman-plugin\n key are recognized:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\nRequired\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\nThe plugins human-readable name. This will be used in the plugin list, for example. Defaults to the package name.\n\n\nNo\n\n\n\n\n\n\ndefaults\n\n\nObject\n\n\nAny default configuration you might need for your plugin. Defaults to an empty hash.\n\n\nNo\n\n\n\n\n\n\n\n\n\n\nMore properties will be added as the development continues.", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#plugins", 
            "text": "Journeyman provides a few ways to add new functionality, that is: To add new, first-class citizen, commands to  journ . In fact,  all  integrated commands are actually plugins. \nPlugins are special npm packages that must fulfill a few requirements:   Their package name starts with  journeyman-plugin- : \n   This serves to keep the npm namespace clean and make plugins more obvious. I can't stand packages like  body-parser  that are secretly  express.js  plugins.  Their  package.json  file includes a  journeyman-plugin  key: \n   This key provides plugin metadata. The available fields are outlined in  Plugin metadata fields  They export a class ( not an instance! ) from their main module that extends the base plugin: \n   Journeyman provides a base class at  lib/plugins/Plugin  that all plugins need to inherit from. It provides several methods Journeyman uses to initialize the plugin and work with it's input and output. This frees implementations from caring about API compatibility and implementation details.   Basically, a plugin provides a new subcommand to journeyman that all its methods are grouped below. A simple plugin might look like this:  const   {   Plugin   }   =   require ( journeyman );  class   EchoPlugin   extends   Plugin   { \n\n   /**     * The static property  name  is used as the subcommand namespace for your plugin     */ \n   static   get   name ()   { \n     return   echo ; \n   } \n\n   /**     * This is a private method (as far as JS supports it, at least...). It will *not* be visible      * nor accessible from the command line due to the single underscore prefix.     */ \n   _prepareOutput ( str )   { \n     return   echo    +   str ; \n   } \n\n   /**     * This is a public method (no leading underscore). It will be used as a publicly visible command below your     * plugin namespace:     * journ echo foo     */ \n   foo ( app )   { \n     const   output   =   this . _prepareOutput ( app . input . args ); \n\n     return   Promise . resolve ( output ); \n   }  }", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#one-shot-plugins", 
            "text": "If your plugin only serves a single purpose -- eg. it doesn't need multiple sub-commands -- you can use one-shot plugins. The only difference to ordinary plugins is that they include the special  __invoke  method: If a plugin provides it, journeyman assumes the plugin doesn't need a namespace and only has a single, public command, callable as  journ  plugin name  --params . If journeyman finds the __invoke method  inside your plugin, it will disregard any other public methods. As ordinary command methods,  __invoke  receives the application instance as its only parameter.  const   {   Plugin   }   =   require ( journeyman );  class   FooPlugin   extends   Plugin   { \n   static   get   name ()   { \n     return   foo ; \n   } \n\n   /**     * This is a special one: For single-shot plugins, you can use the __invoke method.      */ \n   __invoke ( app )   { \n     const   output   =   this . _prepareOutput ( app . input . args ); \n\n     return   Promise . resolve ( output ); \n   }  }", 
            "title": "One-Shot plugins"
        }, 
        {
            "location": "/plugins/#the-app-parameter-to-your-command-methods", 
            "text": "app  is an object with several well-defined properties revolving around the command execution lifecycle. It contains everything the command will need to carry out its purpose:     Name  Type  Description      journeyman  JourneyMan  The current  JourneyMan  instance.    env  Map k: String, v: String  Holds all system environment variables.    input  Input  Holds the command line input object.    output  Output  Holds the command line output object.    plugins  Array Plugin  Holds the list of available plugins. Alias to  journeyman.plugins .    call(command: String): Promise  function  Allows to call other commands by their full command input string.      More properties and methods will be added as the development continues.", 
            "title": "The app parameter to your command methods"
        }, 
        {
            "location": "/plugins/#advanced-plugins", 
            "text": "Single-class and one-shot plugins will be fine for most purposes. But what if you've got actual  work  to do? Fear not, for there's a third structural option: Instead of providing the individual commands as methods on your plugin, you can also provide a list of  Command  instances. \nThis provides you with a belly of additional goodies, like automatic help generation, fine-grained parameter and option handling as well as neatly organized code.  A plugin using Command instances might look like this:  const   {   Plugin   }   =   require ( journeyman );  const   FooCommand   =   require ( ./commands/FooCommand );  const   BarCommand   =   require ( ./commands/BarCommand );  class   MyAdvancedPlugin   extends   Plugin   { \n   static   get   name ()   { \n     return   advanced ; \n   } \n\n   /**     * This overrides the default of an empty array     */ \n   static   get   commands ()   { \n     return   [ \n       FooCommand , \n       BarCommand \n     ]; \n   } \n\n   /**     * Of course, you re still free to define additional commands using methods     */ \n   baz ( app )   { \n     // ... \n   }  }    A command class for our plugin, say  FooCommand , should be constructed like this:  const   {   Command   }   =   require ( journeyman );  class   FooCommand   extends   Command   { \n\n   /**     * Since we don t have a method name at our disposal, we can set it here. If omitted,      * the name will be inferred from the class name ( Class.name.replace( Command ,  ).toLowerCase() )     */ \n   static   get   name ()   { \n     return   foo ; \n   } \n\n   /**     * The __configure() method is called on initialization and allows to configure the command (duh)     */ \n   __configure ()   { \n\n     // a little Symfony-y \n     this . setDescription ( Creates a new foo ); \n     this . addParameter ( name ,   n ,   How to name your foo ,   Command . PARAM_TYPE_STRING ); \n   } \n\n   /**     * The behaviour is the same as with plugin method commands here     */ \n   __invoke ( app )   { \n     return   Promise . resolve (); \n   }  }   That's a whole slew of new stuff, so be sure to check out the  Command documentation .", 
            "title": "Advanced plugins"
        }, 
        {
            "location": "/plugins/#providing-new-commands-for-journeymans-existing-sub-commands", 
            "text": "That's all fine and dandy, but what if you'd like to provide a new  make  something ? For these cases, you can extend the special  MakePlugin  class instead of  Plugin . All commands provided in these will be appended to the  make  subcommand. Beneath  MakePlugin , there's also  LinkPlugin ,  ServePlugin  and  BuildPlugin  to extend the respective verbs.   More extend-plugins will be added as the development continues.", 
            "title": "Providing new commands for journeyman's existing sub-commands"
        }, 
        {
            "location": "/plugins/#plugin-metadata-fields", 
            "text": "The following  package.json  properties of the  journeyman-plugin  key are recognized:     Name  Type  Description  Required      name  String  The plugins human-readable name. This will be used in the plugin list, for example. Defaults to the package name.  No    defaults  Object  Any default configuration you might need for your plugin. Defaults to an empty hash.  No      More properties will be added as the development continues.", 
            "title": "Plugin metadata fields"
        }, 
        {
            "location": "/api/Command/", 
            "text": "Source:\n \nlib/Console/Command.js\n\n\nConsole Command\n\n\nCommands represent complete, CLI-callable commands.\n\n\n\n\n\nnew Command(plugin: \nPlugin\n)\n\n\n\nParameters\n\n\nplugin\n (\nPlugin\n)\n\n\n\n\nStatic Members\n\n\n\n\n$name\n\n\nSource:\n \nlib/Console/Command.js (Lines 22-24)\n\n\nHolds the name of the command.\n\n\n\n\n$name\n\n\n\n\n\nInstance Members\n\n\n\n\ngetName()\n\n\nSource:\n \nlib/Console/Command.js (Lines 82-84)\n\n\nRetrieves the command name\n\n\n\n\ngetName(): \nstring\n\n\n\nReturns\n\n\nstring\n\n\n\n\n\n\n__configure()\n\n\nSource:\n \nlib/Console/Command.js (Lines 151-152)\n\n\nCommand configuration\n\n\nUsing the \n__configure()\n method, you can efficiently define the required syntax for your command.\n\nIf you're familiar with Symfony Console, this will make sense to you immediately. Otherwise,\ncontinue reading.\n\n\n\n\n__configure(): void\n\n\n\nReturns\n\n\nvoid\n\n\n\n\n\n\n__invoke(context)\n\n\nSource:\n \nlib/Console/Command.js (Lines 161-163)\n\n\nExecutes the command. All commands should return a Promise, even though it isn't strictly\nnecessary since you can \nawait\n non-Promise returning functions too.\n\n\n\n\n__invoke(context): (\nPromise\n(\nString\n | \nNumber\n)> | any)\n\n\n\nParameters\n\n\ncontext\n \n\n\n\n\nReturns\n\n\n(\nPromise\n(\nString\n | \nNumber\n)\n | any)\n\n\n\n\n\n\ngetHelp(input, output)\n\n\nSource:\n \nlib/Console/Command.js (Lines 170-181)\n\n\nRetrieves the help text\n\n\n\n\ngetHelp(input, output)\n\n\n\nParameters\n\n\ninput\n \n\n\n\n\noutput\n \n\n\n\n\n\n\n\n\naddArgument(name, flags = CommandArgument.OPTIONAL, description = '', fallback = null)\n\n\nSource:\n \nlib/Console/Command.js (Lines 194-206)\n\n\nAdds a new argument to the command. Please make sure that you add all your arguments in\nthe desired order - arguments provide no clues aside from their position as to which one\nit is, so Journeyman's input component will silently assign them in the order of\nappearance.\n\n\n\n\naddArgument(name: \nString\n, flags: \nNumber\n?, description: \nString\n?, fallback: any?)\n\n\n\nParameters\n\n\nname\n (\nString\n)\n\n\n\n\nargument name\n\n\n\n\nflags\n (\nNumber\n? = CommandArgument.OPTIONAL)\n\n\n\n\nargument type. must use one of the static types (@see CommandArgument#types)\n\n\n\n\ndescription\n (\nString\n? = \n)\n\n\n\n\nargument description for the help text\n\n\n\n\nfallback\n (any? = null)\n\n\n\n\nfallback value if missing. Can only be used for optional arguments\n\n\n\n\n\n\n\n\naddOption(longName, shortName, flags, description, valueLabel)\n\n\nSource:\n \nlib/Console/Command.js (Lines 217-243)\n\n\nAdds a new option to the command\n\n\n\n\naddOption(longName: \nString\n, shortName: \nString\n, flags: \nNumber\n, description: \nString\n, valueLabel: \nString\n)\n\n\n\nParameters\n\n\nlongName\n (\nString\n)\n\n\n\n\nshortName\n (\nString\n = longName.substr(0,1))\n\n\n\n\nflags\n (\nNumber\n = CommandOption.OPTIONAL)\n\n\n\n\ndescription\n (\nString\n = \n)\n\n\n\n\nvalueLabel\n (\nString\n = \n)\n\n\n\n\n\n\n\n\nhasOption(name)\n\n\nSource:\n \nlib/Console/Command.js (Lines 251-253)\n\n\nChecks whether the command has an option\n\n\n\n\nhasOption(name: \nstring\n): \nboolean\n\n\n\nParameters\n\n\nname\n (\nstring\n)\n\n\n\n\nlong name of the option\n\n\n\n\nReturns\n\n\nboolean\n\n\n\n\n\n\nhasOptions()\n\n\nSource:\n \nlib/Console/Command.js (Lines 260-262)\n\n\nChecks whether the command defines any options.\n\n\n\n\nhasOptions(): \nBoolean\n\n\n\nReturns\n\n\nBoolean\n\n\n\n\n\n\ngetOptions()\n\n\nSource:\n \nlib/Console/Command.js (Lines 269-271)\n\n\nRetrieves all command options for the command.\n\n\n\n\ngetOptions(): \nArray\nCommandOption>\n\n\n\nReturns\n\n\nArray\nCommandOption\n\n\n\n\n\n\nhasArguments()\n\n\nSource:\n \nlib/Console/Command.js (Lines 278-280)\n\n\nChecks whether the command defines any arguments.\n\n\n\n\nhasArguments(): \nBoolean\n\n\n\nReturns\n\n\nBoolean\n\n\n\n\n\n\ngetArguments()\n\n\nSource:\n \nlib/Console/Command.js (Lines 287-289)\n\n\nRetrieves all command arguments for the command.\n\n\n\n\ngetArguments(): \nArray\nCommandArgument>\n\n\n\nReturns\n\n\nArray\nCommandArgument\n\n\n\n\n\n\ndefinesInput()\n\n\nSource:\n \nlib/Console/Command.js (Lines 296-298)\n\n\nChecks whether the command defines any input.\n\n\n\n\ndefinesInput(): \nBoolean\n\n\n\nReturns\n\n\nBoolean", 
            "title": "Command"
        }, 
        {
            "location": "/api/Command/#console-command", 
            "text": "Commands represent complete, CLI-callable commands.   \nnew Command(plugin:  Plugin )", 
            "title": "Console Command"
        }, 
        {
            "location": "/api/Command/#parameters", 
            "text": "plugin  ( Plugin )", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Command/#static-members", 
            "text": "$name  Source:   lib/Console/Command.js (Lines 22-24)  Holds the name of the command.   $name", 
            "title": "Static Members"
        }, 
        {
            "location": "/api/Command/#instance-members", 
            "text": "getName()  Source:   lib/Console/Command.js (Lines 82-84)  Retrieves the command name   getName():  string", 
            "title": "Instance Members"
        }, 
        {
            "location": "/api/Command/#returns", 
            "text": "string    __configure()  Source:   lib/Console/Command.js (Lines 151-152)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Command/#command-configuration", 
            "text": "Using the  __configure()  method, you can efficiently define the required syntax for your command. \nIf you're familiar with Symfony Console, this will make sense to you immediately. Otherwise,\ncontinue reading.   __configure(): void", 
            "title": "Command configuration"
        }, 
        {
            "location": "/api/Command/#returns_1", 
            "text": "void    __invoke(context)  Source:   lib/Console/Command.js (Lines 161-163)  Executes the command. All commands should return a Promise, even though it isn't strictly\nnecessary since you can  await  non-Promise returning functions too.   __invoke(context): ( Promise ( String  |  Number )> | any)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Command/#parameters_1", 
            "text": "context", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Command/#returns_2", 
            "text": "( Promise ( String  |  Number )  | any)    getHelp(input, output)  Source:   lib/Console/Command.js (Lines 170-181)  Retrieves the help text   getHelp(input, output)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Command/#parameters_2", 
            "text": "input     output       addArgument(name, flags = CommandArgument.OPTIONAL, description = '', fallback = null)  Source:   lib/Console/Command.js (Lines 194-206)  Adds a new argument to the command. Please make sure that you add all your arguments in\nthe desired order - arguments provide no clues aside from their position as to which one\nit is, so Journeyman's input component will silently assign them in the order of\nappearance.   addArgument(name:  String , flags:  Number ?, description:  String ?, fallback: any?)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Command/#parameters_3", 
            "text": "name  ( String )   argument name   flags  ( Number ? = CommandArgument.OPTIONAL)   argument type. must use one of the static types (@see CommandArgument#types)   description  ( String ? =  )   argument description for the help text   fallback  (any? = null)   fallback value if missing. Can only be used for optional arguments     addOption(longName, shortName, flags, description, valueLabel)  Source:   lib/Console/Command.js (Lines 217-243)  Adds a new option to the command   addOption(longName:  String , shortName:  String , flags:  Number , description:  String , valueLabel:  String )", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Command/#parameters_4", 
            "text": "longName  ( String )   shortName  ( String  = longName.substr(0,1))   flags  ( Number  = CommandOption.OPTIONAL)   description  ( String  =  )   valueLabel  ( String  =  )     hasOption(name)  Source:   lib/Console/Command.js (Lines 251-253)  Checks whether the command has an option   hasOption(name:  string ):  boolean", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Command/#parameters_5", 
            "text": "name  ( string )   long name of the option", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Command/#returns_3", 
            "text": "boolean    hasOptions()  Source:   lib/Console/Command.js (Lines 260-262)  Checks whether the command defines any options.   hasOptions():  Boolean", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Command/#returns_4", 
            "text": "Boolean    getOptions()  Source:   lib/Console/Command.js (Lines 269-271)  Retrieves all command options for the command.   getOptions():  Array CommandOption>", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Command/#returns_5", 
            "text": "Array CommandOption    hasArguments()  Source:   lib/Console/Command.js (Lines 278-280)  Checks whether the command defines any arguments.   hasArguments():  Boolean", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Command/#returns_6", 
            "text": "Boolean    getArguments()  Source:   lib/Console/Command.js (Lines 287-289)  Retrieves all command arguments for the command.   getArguments():  Array CommandArgument>", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Command/#returns_7", 
            "text": "Array CommandArgument    definesInput()  Source:   lib/Console/Command.js (Lines 296-298)  Checks whether the command defines any input.   definesInput():  Boolean", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Command/#returns_8", 
            "text": "Boolean", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Config/", 
            "text": "Source:\n \nlib/Config/Config.js\n\n\nConfiguration storage class\n\n\nConfig presents a wrapper around a physical JSON file. It parses the file on\nconstruction and sets any properties on itself, accessed via getters and setters.\n\nSo basically you get a simple object with ordinary (looking) properties you can get\nor set, but under the hood, each modified property will be written back to the config\nfile asynchronously. This is necessary for commands like \nconfig set \nval\n to work.\n\n\nTo retain a valid and type-safe (as far as JS allows) configuration file, there is\na pretty elaborate feature in place: \nSchema validation\n. This means that a schema is\nin place, describing the available options and their possible values. Every time the\nconfiguration is read, the data will be validated against that schema to make sure it\nis a working configuration.\n\n\nAdditionally, all property changes are validated against the Schema in place. Before\nan option is persisted to the configuration file, it will be validated. If it passes\nthe schema checks, changes will be written, otherwise, it will throw.\n\n\n\n\n\nnew Config(path: \nString\n, configKey: \nString\n?, schema: \nObject\n?)\n\n\n\nParameters\n\n\npath\n (\nString\n)\n\n\n\n\nPath to the file to use\n\n\n\n\nconfigKey\n (\nString\n? = null)\n\n\n\n\nOptional sub-key in the file\n\n\n\n\nschema\n (\nObject\n? = {})\n\n\n\n\nSchema to validate the config with\n\n\n\n\nInstance Members\n\n\n\n\ninitialize()\n\n\nSource:\n \nlib/Config/Config.js (Lines 175-177)\n\n\nConfiguration initialization\n\n\nPopulates the config file with all default values. What this will do is actually just\nan alias for the private \n_update()\n method that takes the plain data and writes it to\nthe given config file path asynchronously.\n\nThings start to get more interesting once we connect the dots though: The \nConfig\n is\ninherently tied to the \nSchema\n it uses. If we run on the vanilla configuration here,\nthat is, there are just no fields set, the available data only consists of default\nvalues. So at that point, we've got a valid (default) configuration in memory but not\nin our file.\n\nUsually, that's fine, that's what defaults are there for. But considering users might\nwant to configure Journeyman, we can spare them the hassle of researching every single\navailable option by simply dumping that memory config into the file they presented to\nus, to be modified by them.\n\nSo this is what this method does: Write the current configuration (assumed to be empty)\ninto the configuration file.\n\n\n\n\ninitialize(): \nPromise\nvoid>\n\n\n\nReturns\n\n\nPromise\nvoid", 
            "title": "Config"
        }, 
        {
            "location": "/api/Config/#configuration-storage-class", 
            "text": "Config presents a wrapper around a physical JSON file. It parses the file on\nconstruction and sets any properties on itself, accessed via getters and setters. \nSo basically you get a simple object with ordinary (looking) properties you can get\nor set, but under the hood, each modified property will be written back to the config\nfile asynchronously. This is necessary for commands like  config set  val  to work.  To retain a valid and type-safe (as far as JS allows) configuration file, there is\na pretty elaborate feature in place:  Schema validation . This means that a schema is\nin place, describing the available options and their possible values. Every time the\nconfiguration is read, the data will be validated against that schema to make sure it\nis a working configuration.  Additionally, all property changes are validated against the Schema in place. Before\nan option is persisted to the configuration file, it will be validated. If it passes\nthe schema checks, changes will be written, otherwise, it will throw.   \nnew Config(path:  String , configKey:  String ?, schema:  Object ?)", 
            "title": "Configuration storage class"
        }, 
        {
            "location": "/api/Config/#parameters", 
            "text": "path  ( String )   Path to the file to use   configKey  ( String ? = null)   Optional sub-key in the file   schema  ( Object ? = {})   Schema to validate the config with", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Config/#instance-members", 
            "text": "initialize()  Source:   lib/Config/Config.js (Lines 175-177)", 
            "title": "Instance Members"
        }, 
        {
            "location": "/api/Config/#configuration-initialization", 
            "text": "Populates the config file with all default values. What this will do is actually just\nan alias for the private  _update()  method that takes the plain data and writes it to\nthe given config file path asynchronously. \nThings start to get more interesting once we connect the dots though: The  Config  is\ninherently tied to the  Schema  it uses. If we run on the vanilla configuration here,\nthat is, there are just no fields set, the available data only consists of default\nvalues. So at that point, we've got a valid (default) configuration in memory but not\nin our file. \nUsually, that's fine, that's what defaults are there for. But considering users might\nwant to configure Journeyman, we can spare them the hassle of researching every single\navailable option by simply dumping that memory config into the file they presented to\nus, to be modified by them. \nSo this is what this method does: Write the current configuration (assumed to be empty)\ninto the configuration file.   initialize():  Promise void>", 
            "title": "Configuration initialization"
        }, 
        {
            "location": "/api/Config/#returns", 
            "text": "Promise void", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Errors/", 
            "text": "Throughout Journeyman, a wide range of errors are used. Instead of throwing generic \nError\ns\nwith a human-readable message, Journeyman uses scoped errors for different possible errors.\nThis makes it possible to transport a lot of metadata, whilst preserving the original cause.\n\n\nAll errors inherit from the base error \nJourneymanError\n.\n\n\nMembers\n\n\n\n\nCommandExecutionError(plugin, handler, error)\n\n\nSource:\n \nlib/Errors/CommandExecutionError.js\n\n\nCommand execution error\n\n\nThis error should be used if a command throws during execution. It indicates the command\nentered some kind of failed state.\n\n\n\n\n\nnew CommandExecutionError(plugin: \nPlugin\n, handler: (\nCommand\n | \nfunction\n), error: \nError\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nplugin\n (\nPlugin\n)\n\n\n\n\nPlugin instance\n\n\n\n\nhandler\n ((\nCommand\n | \nfunction\n))\n\n\n\n\nHandler that failed while handling the command\n\n\n\n\nerror\n (\nError\n)\n\n\n\n\nError that was thrown\n\n\n\n\n\n\n\n\nConfigUpdateError(path, error)\n\n\nSource:\n \nlib/Errors/ConfigUpdateError.js\n\n\nConfiguration update error\n\n\nThis error should be used if an error occurred during writing the configuration to file.\nIt indicates the configuration file could not be persisted to disk.\n\n\n\n\n\nnew ConfigUpdateError(path: \nString\n, error: \nError\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\npath\n (\nString\n)\n\n\n\n\nPath to the configuration file\n\n\n\n\nerror\n (\nError\n)\n\n\n\n\nError that was thrown\n\n\n\n\n\n\n\n\nConfigValidationError(schema, config)\n\n\nSource:\n \nlib/Errors/ConfigValidationError.js\n\n\nConfiguration validation error\n\n\nThis error should be used if an unknown type has been passed to the validation. The Schema class can\nonly validate objects.\n\n\n\n\n\nnew ConfigValidationError(schema: \nSchema\n, config: any)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nschema\n (\nSchema\n)\n\n\n\n\nSchema instance\n\n\n\n\nconfig\n (any)\n\n\n\n\nThe configuration data declared as an object but is none\n\n\n\n\n\n\n\n\nConfigValidationInvalidFieldError(schema, field, value)\n\n\nSource:\n \nlib/Errors/ConfigValidationInvalidFieldError.js\n\n\nConfiguration validation invalid field error\n\n\nThis error should be used if an unknown field has been passed. It indicates the field is missing\nfrom the schema and therefore can't be validated.\n\n\n\n\n\nnew ConfigValidationInvalidFieldError(schema: \nSchema\n, field: \nString\n, value: any)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nschema\n (\nSchema\n)\n\n\n\n\nSchema instance\n\n\n\n\nfield\n (\nString\n)\n\n\n\n\nField that failed validation\n\n\n\n\nvalue\n (any)\n\n\n\n\nValue that failed validation\n\n\n\n\n\n\n\n\nConfigValidationMissingFieldError(schema, config, field)\n\n\nSource:\n \nlib/Errors/ConfigValidationMissingFieldError.js\n\n\nConfiguration validation missing field error\n\n\nThis error should be used if a required schema field is missing. It indicates a certain field must\nbe used but isn't there.\n\n\n\n\n\nnew ConfigValidationMissingFieldError(schema: \nSchema\n, config: \nObject\n, field: \nString\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nschema\n (\nSchema\n)\n\n\n\n\nSchema instance\n\n\n\n\nconfig\n (\nObject\n)\n\n\n\n\nConfiguration data which failed validation\n\n\n\n\nfield\n (\nString\n)\n\n\n\n\nField that failed validation\n\n\n\n\n\n\n\n\nConfigValidationTypeError(schema, field, value, rule)\n\n\nSource:\n \nlib/Errors/ConfigValidationTypeError.js\n\n\nConfiguration validation type error\n\n\nThis error should be used if the schema validation of a field's type fails. It indicates the field\nexists but is of the wrong type.\n\n\n\n\n\nnew ConfigValidationTypeError(schema: \nSchema\n, field: \nString\n, value: any, rule)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nschema\n (\nSchema\n)\n\n\n\n\nSchema instance\n\n\n\n\nfield\n (\nString\n)\n\n\n\n\nField that failed validation\n\n\n\n\nvalue\n (any)\n\n\n\n\nValue that failed validation\n\n\n\n\nrule\n \n\n\n\n\n\n\n\n\nConfigValidationValidatorError(schema, field, value, rule)\n\n\nSource:\n \nlib/Errors/ConfigValidationValidatorError.js\n\n\nConfiguration validation validator error\n\n\nThis error should be used if a field validator throws or returns \nfalse\n. It indicates the field\neither could not be validated (the result was \nfalse\n) or did throw an Error during validation.\n\n\n\n\n\nnew ConfigValidationValidatorError(schema: \nSchema\n, field: \nString\n, value: any, rule)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nschema\n (\nSchema\n)\n\n\n\n\nSchema instance\n\n\n\n\nfield\n (\nString\n)\n\n\n\n\nField that failed validation\n\n\n\n\nvalue\n (any)\n\n\n\n\nValue that failed validation\n\n\n\n\nrule\n \n\n\n\n\n\n\n\n\nInvalidConfigFileError(path, error)\n\n\nSource:\n \nlib/Errors/InvalidConfigFileError.js\n\n\nInvalid configuration file error\n\n\nThis error should be used if the configuration file cannot be read or parsed. Due to the use\nof \nrequire( configFile )\n inside the configuration constructor, this will implicitly be\nthe case if the file path does not exist or points to something apart of \n.js\n or \n.json\n files.\n\n\n\n\n\nnew InvalidConfigFileError(path: \nString\n, error: \nError\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\npath\n (\nString\n)\n\n\n\n\nPath to the invalid configuration file\n\n\n\n\nerror\n (\nError\n)\n\n\n\n\nError that was thrown\n\n\n\n\n\n\n\n\nInvalidInstantiationError(command, plugin)\n\n\nSource:\n \nlib/Errors/InvalidInstantiationError.js\n\n\nInvalid instantiation error error\n\n\nThis error should be used if a command is being instantiated with anything but a valid\nPlugin instance. It indicates a command has been constructed manually somewhere which\nis considered unsafe.\n\n\n\n\n\nnew InvalidInstantiationError(command: \nCommand\n, plugin: \nPlugin\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\ncommand\n (\nCommand\n)\n\n\n\n\nInstance of the command that caused the error\n\n\n\n\nplugin\n (\nPlugin\n)\n\n\n\n\nWhatever has been passed as a plugin but is none\n\n\n\n\n\n\n\n\nInvalidPluginError(loader, plugin)\n\n\nSource:\n \nlib/Errors/InvalidPluginError.js\n\n\nInvalid plugin error\n\n\nThis error should be used if a bad module is encountered by the plugin loader. It\nindicates a module declares itself as a journeyman plugin but doesn't work according to\nthe plugin specification.\n\n\n\n\n\nnew InvalidPluginError(loader: \nLoader\n, plugin: \nPlugin\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nloader\n (\nLoader\n)\n\n\n\n\nInstance of the plugin loader\n\n\n\n\nplugin\n (\nPlugin\n)\n\n\n\n\nInstance of the invalid Plugin\n\n\n\n\n\n\n\n\nPluginDiscoveryError(loader, path, error)\n\n\nSource:\n \nlib/Errors/PluginDiscoveryError.js\n\n\nPlugin discovery error\n\n\nThis error should be used if the plugin discovery failed. It indicates there is a problem\npreventing the plugin loader from discovering plugins, likely at the filesystem level.\n\n\n\n\n\nnew PluginDiscoveryError(loader: \nLoader\n, path: \nString\n, error: \nError\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nloader\n (\nLoader\n)\n\n\n\n\nInstance of the plugin loader\n\n\n\n\npath\n (\nString\n)\n\n\n\n\nPath to the directory that caused the error\n\n\n\n\nerror\n (\nError\n)\n\n\n\n\nError that was thrown\n\n\n\n\n\n\n\n\nPluginLoadError(loader, path, error)\n\n\nSource:\n \nlib/Errors/PluginLoadError.js\n\n\nPlugin load error\n\n\nThis error should be used if a plugin can't be loaded. It indicates there is a problem when\ncalling \nrequire( pluginPath )\n to load the module.\n\n\n\n\n\nnew PluginLoadError(loader: \nLoader\n, path: \nString\n, error: \nError\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nloader\n (\nLoader\n)\n\n\n\n\nInstance of the plugin loader\n\n\n\n\npath\n (\nString\n)\n\n\n\n\nPath to the plugin that caused the error\n\n\n\n\nerror\n (\nError\n)\n\n\n\n\nError that was thrown\n\n\n\n\n\n\n\n\nRequiredCommandArgumentMissingError(command, argument, input)\n\n\nSource:\n \nlib/Errors/RequiredCommandArgumentMissingError.js\n\n\nCommand execution error\n\n\nThis error should be used if a command throws during execution. It indicates the command\nentered some kind of failed state.\n\n\n\n\n\nnew RequiredCommandArgumentMissingError(command: \nCommand\n, argument: CommandArgument, input: \nInput\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\ncommand\n (\nCommand\n)\n\n\n\n\nCommand instance\n\n\n\n\nargument\n (CommandArgument)\n\n\n\n\nDefinition for command option that is missing\n\n\n\n\ninput\n (\nInput\n)\n\n\n\n\nInput instance for the current process\n\n\n\n\n\n\n\n\nRequiredCommandOptionMissingError(command, option, input)\n\n\nSource:\n \nlib/Errors/RequiredCommandOptionMissingError.js\n\n\nCommand execution error\n\n\nThis error should be used if a command throws during execution. It indicates the command\nentered some kind of failed state.\n\n\n\n\n\nnew RequiredCommandOptionMissingError(command: \nCommand\n, option: CommandOption, input: \nInput\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\ncommand\n (\nCommand\n)\n\n\n\n\nCommand instance\n\n\n\n\noption\n (CommandOption)\n\n\n\n\nDefinition for command option that is missing\n\n\n\n\ninput\n (\nInput\n)\n\n\n\n\nInput instance for the current process\n\n\n\n\n\n\n\n\nRequiredCommandOptionValueMissingError(command, option, input)\n\n\nSource:\n \nlib/Errors/RequiredCommandOptionValueMissingError.js\n\n\nCommand execution error\n\n\nThis error should be used if a command throws during execution. It indicates the command\nentered some kind of failed state.\n\n\n\n\n\nnew RequiredCommandOptionValueMissingError(command: \nCommand\n, option: CommandOption, input: \nInput\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\ncommand\n (\nCommand\n)\n\n\n\n\nCommand instance\n\n\n\n\noption\n (CommandOption)\n\n\n\n\nDefinition for command option that is missing\n\n\n\n\ninput\n (\nInput\n)\n\n\n\n\nInput instance for the current process\n\n\n\n\n\n\n\n\nUnknownCommandError(plugin, command)\n\n\nSource:\n \nlib/Errors/UnknownCommandError.js\n\n\nUnknown command error\n\n\nThis error should be used if a call for a plugin command cannot be resolved to a command. It\nindicates the plugin sub-command is valid (the plugin exists and is loaded) but there is no\nhandler to handle the specific command called.\n\n\n\n\n\nnew UnknownCommandError(plugin: \nPlugin\n, command: \nString\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\nplugin\n (\nPlugin\n)\n\n\n\n\nInstance of the plugin the error was thrown in\n\n\n\n\ncommand\n (\nString\n)\n\n\n\n\nCommand requested\n\n\n\n\n\n\n\n\nUnknownPluginError(journeyman, plugin)\n\n\nSource:\n \nlib/Errors/UnknownPluginError.js\n\n\nUnknown plugin error\n\n\nThis error should be used if a call for a plugin cannot be resolved to a plugin class. It\nindicates the plugin sub-command is invalid (the plugin does not exist) so there is no\nhandler to handle the plugin call. Likely a typo.\n\n\n\n\n\nnew UnknownPluginError(journeyman: \nJourneyMan\n, plugin: \nString\n)\n\n\n\nExtends\n\n\nJourneymanError\n\n\nParameters\n\n\njourneyman\n (\nJourneyMan\n)\n\n\n\n\nInstance of the Journeyman application\n\n\n\n\nplugin\n (\nString\n)\n\n\n\n\nPlugin requested", 
            "title": "Errors"
        }, 
        {
            "location": "/api/Errors/#members", 
            "text": "CommandExecutionError(plugin, handler, error)  Source:   lib/Errors/CommandExecutionError.js", 
            "title": "Members"
        }, 
        {
            "location": "/api/Errors/#command-execution-error", 
            "text": "This error should be used if a command throws during execution. It indicates the command\nentered some kind of failed state.   \nnew CommandExecutionError(plugin:  Plugin , handler: ( Command  |  function ), error:  Error )", 
            "title": "Command execution error"
        }, 
        {
            "location": "/api/Errors/#extends", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters", 
            "text": "plugin  ( Plugin )   Plugin instance   handler  (( Command  |  function ))   Handler that failed while handling the command   error  ( Error )   Error that was thrown     ConfigUpdateError(path, error)  Source:   lib/Errors/ConfigUpdateError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#configuration-update-error", 
            "text": "This error should be used if an error occurred during writing the configuration to file.\nIt indicates the configuration file could not be persisted to disk.   \nnew ConfigUpdateError(path:  String , error:  Error )", 
            "title": "Configuration update error"
        }, 
        {
            "location": "/api/Errors/#extends_1", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_1", 
            "text": "path  ( String )   Path to the configuration file   error  ( Error )   Error that was thrown     ConfigValidationError(schema, config)  Source:   lib/Errors/ConfigValidationError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#configuration-validation-error", 
            "text": "This error should be used if an unknown type has been passed to the validation. The Schema class can\nonly validate objects.   \nnew ConfigValidationError(schema:  Schema , config: any)", 
            "title": "Configuration validation error"
        }, 
        {
            "location": "/api/Errors/#extends_2", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_2", 
            "text": "schema  ( Schema )   Schema instance   config  (any)   The configuration data declared as an object but is none     ConfigValidationInvalidFieldError(schema, field, value)  Source:   lib/Errors/ConfigValidationInvalidFieldError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#configuration-validation-invalid-field-error", 
            "text": "This error should be used if an unknown field has been passed. It indicates the field is missing\nfrom the schema and therefore can't be validated.   \nnew ConfigValidationInvalidFieldError(schema:  Schema , field:  String , value: any)", 
            "title": "Configuration validation invalid field error"
        }, 
        {
            "location": "/api/Errors/#extends_3", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_3", 
            "text": "schema  ( Schema )   Schema instance   field  ( String )   Field that failed validation   value  (any)   Value that failed validation     ConfigValidationMissingFieldError(schema, config, field)  Source:   lib/Errors/ConfigValidationMissingFieldError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#configuration-validation-missing-field-error", 
            "text": "This error should be used if a required schema field is missing. It indicates a certain field must\nbe used but isn't there.   \nnew ConfigValidationMissingFieldError(schema:  Schema , config:  Object , field:  String )", 
            "title": "Configuration validation missing field error"
        }, 
        {
            "location": "/api/Errors/#extends_4", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_4", 
            "text": "schema  ( Schema )   Schema instance   config  ( Object )   Configuration data which failed validation   field  ( String )   Field that failed validation     ConfigValidationTypeError(schema, field, value, rule)  Source:   lib/Errors/ConfigValidationTypeError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#configuration-validation-type-error", 
            "text": "This error should be used if the schema validation of a field's type fails. It indicates the field\nexists but is of the wrong type.   \nnew ConfigValidationTypeError(schema:  Schema , field:  String , value: any, rule)", 
            "title": "Configuration validation type error"
        }, 
        {
            "location": "/api/Errors/#extends_5", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_5", 
            "text": "schema  ( Schema )   Schema instance   field  ( String )   Field that failed validation   value  (any)   Value that failed validation   rule       ConfigValidationValidatorError(schema, field, value, rule)  Source:   lib/Errors/ConfigValidationValidatorError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#configuration-validation-validator-error", 
            "text": "This error should be used if a field validator throws or returns  false . It indicates the field\neither could not be validated (the result was  false ) or did throw an Error during validation.   \nnew ConfigValidationValidatorError(schema:  Schema , field:  String , value: any, rule)", 
            "title": "Configuration validation validator error"
        }, 
        {
            "location": "/api/Errors/#extends_6", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_6", 
            "text": "schema  ( Schema )   Schema instance   field  ( String )   Field that failed validation   value  (any)   Value that failed validation   rule       InvalidConfigFileError(path, error)  Source:   lib/Errors/InvalidConfigFileError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#invalid-configuration-file-error", 
            "text": "This error should be used if the configuration file cannot be read or parsed. Due to the use\nof  require( configFile )  inside the configuration constructor, this will implicitly be\nthe case if the file path does not exist or points to something apart of  .js  or  .json  files.   \nnew InvalidConfigFileError(path:  String , error:  Error )", 
            "title": "Invalid configuration file error"
        }, 
        {
            "location": "/api/Errors/#extends_7", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_7", 
            "text": "path  ( String )   Path to the invalid configuration file   error  ( Error )   Error that was thrown     InvalidInstantiationError(command, plugin)  Source:   lib/Errors/InvalidInstantiationError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#invalid-instantiation-error-error", 
            "text": "This error should be used if a command is being instantiated with anything but a valid\nPlugin instance. It indicates a command has been constructed manually somewhere which\nis considered unsafe.   \nnew InvalidInstantiationError(command:  Command , plugin:  Plugin )", 
            "title": "Invalid instantiation error error"
        }, 
        {
            "location": "/api/Errors/#extends_8", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_8", 
            "text": "command  ( Command )   Instance of the command that caused the error   plugin  ( Plugin )   Whatever has been passed as a plugin but is none     InvalidPluginError(loader, plugin)  Source:   lib/Errors/InvalidPluginError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#invalid-plugin-error", 
            "text": "This error should be used if a bad module is encountered by the plugin loader. It\nindicates a module declares itself as a journeyman plugin but doesn't work according to\nthe plugin specification.   \nnew InvalidPluginError(loader:  Loader , plugin:  Plugin )", 
            "title": "Invalid plugin error"
        }, 
        {
            "location": "/api/Errors/#extends_9", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_9", 
            "text": "loader  ( Loader )   Instance of the plugin loader   plugin  ( Plugin )   Instance of the invalid Plugin     PluginDiscoveryError(loader, path, error)  Source:   lib/Errors/PluginDiscoveryError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#plugin-discovery-error", 
            "text": "This error should be used if the plugin discovery failed. It indicates there is a problem\npreventing the plugin loader from discovering plugins, likely at the filesystem level.   \nnew PluginDiscoveryError(loader:  Loader , path:  String , error:  Error )", 
            "title": "Plugin discovery error"
        }, 
        {
            "location": "/api/Errors/#extends_10", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_10", 
            "text": "loader  ( Loader )   Instance of the plugin loader   path  ( String )   Path to the directory that caused the error   error  ( Error )   Error that was thrown     PluginLoadError(loader, path, error)  Source:   lib/Errors/PluginLoadError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#plugin-load-error", 
            "text": "This error should be used if a plugin can't be loaded. It indicates there is a problem when\ncalling  require( pluginPath )  to load the module.   \nnew PluginLoadError(loader:  Loader , path:  String , error:  Error )", 
            "title": "Plugin load error"
        }, 
        {
            "location": "/api/Errors/#extends_11", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_11", 
            "text": "loader  ( Loader )   Instance of the plugin loader   path  ( String )   Path to the plugin that caused the error   error  ( Error )   Error that was thrown     RequiredCommandArgumentMissingError(command, argument, input)  Source:   lib/Errors/RequiredCommandArgumentMissingError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#command-execution-error_1", 
            "text": "This error should be used if a command throws during execution. It indicates the command\nentered some kind of failed state.   \nnew RequiredCommandArgumentMissingError(command:  Command , argument: CommandArgument, input:  Input )", 
            "title": "Command execution error"
        }, 
        {
            "location": "/api/Errors/#extends_12", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_12", 
            "text": "command  ( Command )   Command instance   argument  (CommandArgument)   Definition for command option that is missing   input  ( Input )   Input instance for the current process     RequiredCommandOptionMissingError(command, option, input)  Source:   lib/Errors/RequiredCommandOptionMissingError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#command-execution-error_2", 
            "text": "This error should be used if a command throws during execution. It indicates the command\nentered some kind of failed state.   \nnew RequiredCommandOptionMissingError(command:  Command , option: CommandOption, input:  Input )", 
            "title": "Command execution error"
        }, 
        {
            "location": "/api/Errors/#extends_13", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_13", 
            "text": "command  ( Command )   Command instance   option  (CommandOption)   Definition for command option that is missing   input  ( Input )   Input instance for the current process     RequiredCommandOptionValueMissingError(command, option, input)  Source:   lib/Errors/RequiredCommandOptionValueMissingError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#command-execution-error_3", 
            "text": "This error should be used if a command throws during execution. It indicates the command\nentered some kind of failed state.   \nnew RequiredCommandOptionValueMissingError(command:  Command , option: CommandOption, input:  Input )", 
            "title": "Command execution error"
        }, 
        {
            "location": "/api/Errors/#extends_14", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_14", 
            "text": "command  ( Command )   Command instance   option  (CommandOption)   Definition for command option that is missing   input  ( Input )   Input instance for the current process     UnknownCommandError(plugin, command)  Source:   lib/Errors/UnknownCommandError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#unknown-command-error", 
            "text": "This error should be used if a call for a plugin command cannot be resolved to a command. It\nindicates the plugin sub-command is valid (the plugin exists and is loaded) but there is no\nhandler to handle the specific command called.   \nnew UnknownCommandError(plugin:  Plugin , command:  String )", 
            "title": "Unknown command error"
        }, 
        {
            "location": "/api/Errors/#extends_15", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_15", 
            "text": "plugin  ( Plugin )   Instance of the plugin the error was thrown in   command  ( String )   Command requested     UnknownPluginError(journeyman, plugin)  Source:   lib/Errors/UnknownPluginError.js", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Errors/#unknown-plugin-error", 
            "text": "This error should be used if a call for a plugin cannot be resolved to a plugin class. It\nindicates the plugin sub-command is invalid (the plugin does not exist) so there is no\nhandler to handle the plugin call. Likely a typo.   \nnew UnknownPluginError(journeyman:  JourneyMan , plugin:  String )", 
            "title": "Unknown plugin error"
        }, 
        {
            "location": "/api/Errors/#extends_16", 
            "text": "JourneymanError", 
            "title": "Extends"
        }, 
        {
            "location": "/api/Errors/#parameters_16", 
            "text": "journeyman  ( JourneyMan )   Instance of the Journeyman application   plugin  ( String )   Plugin requested", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Input/", 
            "text": "Source:\n \nlib/Console/Input.js\n\n\nRepresents the command input for the application\n\n\n\n\n\nnew Input(args: \nString\n)\n\n\n\nParameters\n\n\nargs\n (\nString\n)\n\n\n\n\nConsole arguments\n\n\n\n\nInstance Members\n\n\n\n\nraw\n\n\nSource:\n \nlib/Console/Input.js (Lines 27-27)\n\n\nHolds the original input args.\n\n\n\n\nraw\n\n\n\n\n\n\n\nplugin\n\n\nSource:\n \nlib/Console/Input.js (Lines 34-34)\n\n\nHolds the plugin identifier. This will generally be the first sub-command to Journeyman.\n\n\n\n\nplugin\n\n\n\n\n\n\n\ncommand\n\n\nSource:\n \nlib/Console/Input.js (Lines 41-41)\n\n\nHolds the command identifier. This will generally be the second sub-command to Journeyman.\n\n\n\n\ncommand\n\n\n\n\n\n\n\narguments\n\n\nSource:\n \nlib/Console/Input.js (Lines 48-48)\n\n\nHolds the command arguments passed to Journeyman, except the plugin and command identifiers.\n\n\n\n\narguments\n\n\n\n\n\n\n\nhasArguments()\n\n\nSource:\n \nlib/Console/Input.js (Lines 77-79)\n\n\nChecks whether any arguments have been passed.\n\n\n\n\nhasArguments(): \nBoolean\n\n\n\nReturns\n\n\nBoolean\n\n\n\n\n\n\nhasArgument(argument)\n\n\nSource:\n \nlib/Console/Input.js (Lines 87-93)\n\n\nChecks whether an argument at a specific position exists.\n\n\n\n\nhasArgument(argument: (\nString\n | \nNumber\n)): \nBoolean\n\n\n\nParameters\n\n\nargument\n ((\nString\n | \nNumber\n))\n\n\n\n\nDefined argument name or position of the argument.\n\n\n\n\nReturns\n\n\nBoolean\n\n\n\n\n\n\ngetArgument(argument = 0)\n\n\nSource:\n \nlib/Console/Input.js (Lines 102-108)\n\n\nRetrieves an input argument by position.\n\n\n\n\ngetArgument(argument: (\nString\n | \nNumber\n)?): any\n\n\n\nParameters\n\n\nargument\n ((\nString\n | \nNumber\n)? = 0)\n\n\n\n\nDefined argument name or position of the argument.                                    Defaults to 0.\n\n\n\n\nReturns\n\n\nany\n\n\n\n\n\n\nhasOption(option)\n\n\nSource:\n \nlib/Console/Input.js (Lines 116-125)\n\n\nChecks whether a specific option has been passed.\n\n\n\n\nhasOption(option: (CommandOption | \nString\n)): \nBoolean\n\n\n\nParameters\n\n\noption\n ((CommandOption | \nString\n))\n\n\n\n\nName of the option to check for\n\n\n\n\nReturns\n\n\nBoolean\n\n\n\n\n\n\ngetOption(option, fallback = false)\n\n\nSource:\n \nlib/Console/Input.js (Lines 134-148)\n\n\nRetrieves an input option. This method accepts both \nCommandOption\n instances and string identifiers.\n\n\n\n\ngetOption(option: (CommandOption | \nString\n), fallback: any?): any\n\n\n\nParameters\n\n\noption\n ((CommandOption | \nString\n))\n\n\n\n\nOption instance or name\n\n\n\n\nfallback\n (any? = false)\n\n\n\n\nOptional fallback value if the requested option is missing\n\n\n\n\nReturns\n\n\nany\n\n\n\n\n\n\nvalidate(command)\n\n\nSource:\n \nlib/Console/Input.js (Lines 173-223)\n\n\nValidates a command's input definitions.\n\n\n\n\nvalidate(command: \nCommand\n)\n\n\n\nParameters\n\n\ncommand\n (\nCommand\n)\n\n\n\n\nCommand instance to validate definitions for.", 
            "title": "Input"
        }, 
        {
            "location": "/api/Input/#parameters", 
            "text": "args  ( String )   Console arguments", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Input/#instance-members", 
            "text": "raw  Source:   lib/Console/Input.js (Lines 27-27)  Holds the original input args.   raw    plugin  Source:   lib/Console/Input.js (Lines 34-34)  Holds the plugin identifier. This will generally be the first sub-command to Journeyman.   plugin    command  Source:   lib/Console/Input.js (Lines 41-41)  Holds the command identifier. This will generally be the second sub-command to Journeyman.   command    arguments  Source:   lib/Console/Input.js (Lines 48-48)  Holds the command arguments passed to Journeyman, except the plugin and command identifiers.   arguments    hasArguments()  Source:   lib/Console/Input.js (Lines 77-79)  Checks whether any arguments have been passed.   hasArguments():  Boolean", 
            "title": "Instance Members"
        }, 
        {
            "location": "/api/Input/#returns", 
            "text": "Boolean    hasArgument(argument)  Source:   lib/Console/Input.js (Lines 87-93)  Checks whether an argument at a specific position exists.   hasArgument(argument: ( String  |  Number )):  Boolean", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Input/#parameters_1", 
            "text": "argument  (( String  |  Number ))   Defined argument name or position of the argument.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Input/#returns_1", 
            "text": "Boolean    getArgument(argument = 0)  Source:   lib/Console/Input.js (Lines 102-108)  Retrieves an input argument by position.   getArgument(argument: ( String  |  Number )?): any", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Input/#parameters_2", 
            "text": "argument  (( String  |  Number )? = 0)   Defined argument name or position of the argument.                                    Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Input/#returns_2", 
            "text": "any    hasOption(option)  Source:   lib/Console/Input.js (Lines 116-125)  Checks whether a specific option has been passed.   hasOption(option: (CommandOption |  String )):  Boolean", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Input/#parameters_3", 
            "text": "option  ((CommandOption |  String ))   Name of the option to check for", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Input/#returns_3", 
            "text": "Boolean    getOption(option, fallback = false)  Source:   lib/Console/Input.js (Lines 134-148)  Retrieves an input option. This method accepts both  CommandOption  instances and string identifiers.   getOption(option: (CommandOption |  String ), fallback: any?): any", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Input/#parameters_4", 
            "text": "option  ((CommandOption |  String ))   Option instance or name   fallback  (any? = false)   Optional fallback value if the requested option is missing", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Input/#returns_4", 
            "text": "any    validate(command)  Source:   lib/Console/Input.js (Lines 173-223)  Validates a command's input definitions.   validate(command:  Command )", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Input/#parameters_5", 
            "text": "command  ( Command )   Command instance to validate definitions for.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/JourneyMan/", 
            "text": "Source:\n \nlib/JourneyMan.js\n\n\nWelcome to JourneyMan!\nThis is the main class used by the CLI, but it's easy to use it programmatically. There are two\nexternal requirements to Journeyman:\n\n\n\n\nA valid, physical configuration file\n\n\nSome kind of \nprocess\n implementation\n\n    It doesn't matter if this will be the actual \nprocess\n global or a replacement object, as\n    long as it provides the properties \nargv\n (the command line input), \ncwd()\n (function that\n    returns the current working directory), \nenv\n (a key-value hash that holds all environment\n    variables).\n\n\n\n\nIn order to work with Journeyman, you'll first need to create a new instance:\n\n\nconst\n \nJourneyMan\n \n=\n \nrequire\n(\njourneyman\n);\n\n\n\n// note that we only need a directory here, the file\n\n\n// resolution is performed by JourneyMan itself\n\n\nconst\n \njourneyman\n \n=\n \nnew\n \nJourneyMan\n(\n/path/to/config/\n);\n\n\n\n\n\nThis will initialize the object. To kick off the actual process, you'll need to call \nrun()\n:\n\n\njourneyman\n.\nrun\n({\n \nargv\n:\n \n[\nfoo\n,\nbar\n,\n--baz\n],\n \nenv\n:\n \n{},\n \ncwd\n()\n \n{\nreturn\n \n/\n}\n \n});\n\n\n\n\n\n\n\n\nnew JourneyMan(configFilePath: \nString\n)\n\n\n\nParameters\n\n\nconfigFilePath\n (\nString\n = process.cwd())\n\n\n\n\nPath to the configuration file.\n\n\n\n\nStatic Members\n\n\n\n\nPlugin()\n\n\nSource:\n \nlib/JourneyMan.js\n\n\nStatic getter for the Plugin class. This provides \nPlugin\n to plugins without having to\nrequire the actual file itself. Plugin authors are advised to use this property since the\npath to the class might change at any time. \nJourneyMan\n \nis\n the stable API.\n\n\n\n\n\nnew Plugin(): \nPlugin\n\n\n\nReturns\n\n\nPlugin\n\n\n\n\n\n\nCommand()\n\n\nSource:\n \nlib/JourneyMan.js\n\n\nStatic getter for the Command class. This provides \nCommand\n to plugins without having to\nrequire the actual file itself. Plugin authors are advised to use this property since the\npath to the class might change at any time. \nJourneyMan\n \nis\n the stable API.\n\n\n\n\n\nnew Command(): \nCommand\n\n\n\nReturns\n\n\nCommand\n\n\n\n\nInstance Members\n\n\n\n\nconfig\n\n\nSource:\n \nlib/JourneyMan.js (Lines 87-89)\n\n\nHolds Config instance for the application. Journeyman will generally first try to load\na file called \n.journeyman\n. If it is available, a new Config will be created with no\nsub-key (\n.journeyman\n files are expected to only contain Journeyman configuration).\nIn case there is none, Journeyman will try to find and load a \npackage.json\n file in\nthe current directory.\n\n\n\n\nconfig\n\n\n\n\n\n\n\nrun(proc)\n\n\nSource:\n \nlib/JourneyMan.js (Lines 111-141)\n\n\nRuns the application. This is kind of the \n\"main\"\n function in Journeyman, kicking off the\nentire process chain. In order, the input is detected, plugins are loaded and the correct\ncommand is routed.\n\nThe output produced by any command than ran will be returned as the result; if anything\nthrows, it will bubble up to this point. Catching these exceptions is up to the final\nimplementation: Either a programmatic consumer or the CLI app \njourn\n.\n\n\n\n\nrun(proc: \nObject\n): \nPromise\nany>\n\n\n\nParameters\n\n\nproc\n (\nObject\n)\n\n\n\n\nProcess object. While in node, \nprocess\n is a global, we want                                JourneyMan to stay as portable as possible. Therefore, process                                is a freely shimable dependency here.\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n| \nproc.argv\n \nString\n\n   | Command line arguments\n |\n\n\n| \nproc.cwd\n \nfunction\n\n   | Current working directory\n |\n\n\n| \nproc.stdout\n \nWritableStream\n\n   | Standard output\n |\n\n\n| \nproc.stderr\n \nWritableStream\n\n   | Standard error output\n |\n\n\nReturns\n\n\nPromise\nany\n\n\n\n\n\n\ninput\n\n\nSource:\n \nlib/JourneyMan.js (Lines 118-118)\n\n\nHolds the command line input.\n\n\n\n\ninput", 
            "title": "JourneyMan"
        }, 
        {
            "location": "/api/JourneyMan/#parameters", 
            "text": "configFilePath  ( String  = process.cwd())   Path to the configuration file.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/JourneyMan/#static-members", 
            "text": "Plugin()  Source:   lib/JourneyMan.js  Static getter for the Plugin class. This provides  Plugin  to plugins without having to\nrequire the actual file itself. Plugin authors are advised to use this property since the\npath to the class might change at any time.  JourneyMan   is  the stable API.   \nnew Plugin():  Plugin", 
            "title": "Static Members"
        }, 
        {
            "location": "/api/JourneyMan/#returns", 
            "text": "Plugin    Command()  Source:   lib/JourneyMan.js  Static getter for the Command class. This provides  Command  to plugins without having to\nrequire the actual file itself. Plugin authors are advised to use this property since the\npath to the class might change at any time.  JourneyMan   is  the stable API.   \nnew Command():  Command", 
            "title": "Returns"
        }, 
        {
            "location": "/api/JourneyMan/#returns_1", 
            "text": "Command", 
            "title": "Returns"
        }, 
        {
            "location": "/api/JourneyMan/#instance-members", 
            "text": "config  Source:   lib/JourneyMan.js (Lines 87-89)  Holds Config instance for the application. Journeyman will generally first try to load\na file called  .journeyman . If it is available, a new Config will be created with no\nsub-key ( .journeyman  files are expected to only contain Journeyman configuration).\nIn case there is none, Journeyman will try to find and load a  package.json  file in\nthe current directory.   config    run(proc)  Source:   lib/JourneyMan.js (Lines 111-141)  Runs the application. This is kind of the  \"main\"  function in Journeyman, kicking off the\nentire process chain. In order, the input is detected, plugins are loaded and the correct\ncommand is routed. \nThe output produced by any command than ran will be returned as the result; if anything\nthrows, it will bubble up to this point. Catching these exceptions is up to the final\nimplementation: Either a programmatic consumer or the CLI app  journ .   run(proc:  Object ):  Promise any>", 
            "title": "Instance Members"
        }, 
        {
            "location": "/api/JourneyMan/#parameters_1", 
            "text": "proc  ( Object )   Process object. While in node,  process  is a global, we want                                JourneyMan to stay as portable as possible. Therefore, process                                is a freely shimable dependency here.      Name  Description           |  proc.argv   String \n   | Command line arguments\n |  |  proc.cwd   function \n   | Current working directory\n |  |  proc.stdout   WritableStream \n   | Standard output\n |  |  proc.stderr   WritableStream \n   | Standard error output\n |", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/JourneyMan/#returns_2", 
            "text": "Promise any    input  Source:   lib/JourneyMan.js (Lines 118-118)  Holds the command line input.   input", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Loader/", 
            "text": "Source:\n \nlib/Plugins/Loader.js\n\n\nPlugin loader\n\n\nThe plugin loader iterates over any directories that might contain plugins for journeyman.\n\nThe loader itself, however, doesn't keep a static directory list but rather relies on calls to\nthe \ndiscover()\n method that accepts either single directories as strings or an array of paths.\n\n\nWhen called, the method reads the path's content and checks each entry against a set of rules\nin the static \nrules\n property. If the path passes the rules, the directory is regarded as being\na Journeyman plugin and it will be loaded in the application.\nBy default, both the global node_modules directory and one in the current working directory are\nincluded in the discovery - yes, this contradicts the statement on hardcoded paths, however this\nis standard behavior not up for changes. Additionally, the loader relies on an instance of the\nglobal \nnpm\n module being passed to it's constructor which both paths are inferred from.\n\n\n\n\n\nnew Loader(npm: \nObject\n)\n\n\n\nParameters\n\n\nnpm\n (\nObject\n)\n\n\n\n\nStatic Members\n\n\n\n\nrules\n\n\nSource:\n \nlib/Plugins/Loader.js (Lines 35-62)\n\n\nHolds plugin validation rules\n\n\n\n\nrules\n\n\n\nReturns\n\n\n{name: (function (\nString\n): \nBoolean\n), isPlugin: (function (\nObject\n): \nboolean\n)}\n\n\n\n\nInstance Members\n\n\n\n\ndiscover(searchPaths)\n\n\nSource:\n \nlib/Plugins/Loader.js (Lines 85-104)\n\n\nDiscovers plugins in one or more specific search paths\n\n\n\n\ndiscover(searchPaths: (\nArray\n | \nString\n)): \nPromise\nArray\n>\n\n\n\nParameters\n\n\nsearchPaths\n ((\nArray\n | \nString\n) = [])\n\n\n\n\nReturns\n\n\nPromise\nArray", 
            "title": "Loader"
        }, 
        {
            "location": "/api/Loader/#plugin-loader", 
            "text": "The plugin loader iterates over any directories that might contain plugins for journeyman. \nThe loader itself, however, doesn't keep a static directory list but rather relies on calls to\nthe  discover()  method that accepts either single directories as strings or an array of paths.  When called, the method reads the path's content and checks each entry against a set of rules\nin the static  rules  property. If the path passes the rules, the directory is regarded as being\na Journeyman plugin and it will be loaded in the application.\nBy default, both the global node_modules directory and one in the current working directory are\nincluded in the discovery - yes, this contradicts the statement on hardcoded paths, however this\nis standard behavior not up for changes. Additionally, the loader relies on an instance of the\nglobal  npm  module being passed to it's constructor which both paths are inferred from.   \nnew Loader(npm:  Object )", 
            "title": "Plugin loader"
        }, 
        {
            "location": "/api/Loader/#parameters", 
            "text": "npm  ( Object )", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Loader/#static-members", 
            "text": "rules  Source:   lib/Plugins/Loader.js (Lines 35-62)  Holds plugin validation rules   rules", 
            "title": "Static Members"
        }, 
        {
            "location": "/api/Loader/#returns", 
            "text": "{name: (function ( String ):  Boolean ), isPlugin: (function ( Object ):  boolean )}", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Loader/#instance-members", 
            "text": "discover(searchPaths)  Source:   lib/Plugins/Loader.js (Lines 85-104)  Discovers plugins in one or more specific search paths   discover(searchPaths: ( Array  |  String )):  Promise Array >", 
            "title": "Instance Members"
        }, 
        {
            "location": "/api/Loader/#parameters_1", 
            "text": "searchPaths  (( Array  |  String ) = [])", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Loader/#returns_1", 
            "text": "Promise Array", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Output/", 
            "text": "Source:\n \nlib/Console/Output.js\n\n\nConsole output\n\n\nThe \nOutput\n class is responsible for buffering the console output.\n\n\n\n\n\nnew Output(outputStream: WritableStream, verbosity: \nNumber\n?, formatter: \nFunction\n?)\n\n\n\nParameters\n\n\noutputStream\n (WritableStream)\n\n\n\n\nverbosity\n (\nNumber\n? = this.constructor.VERBOSITY_DEFAULT)\n\n\n\n\nformatter\n (\nFunction\n? = this.constructor._DEFAULT_FORMATTER)\n\n\n\n\nInstance Members\n\n\n\n\nverbosity\n\n\nSource:\n \nlib/Console/Output.js (Lines 52-52)\n\n\nHolds the output verbosity\n\n\n\n\nverbosity\n\n\n\n\n\n\n\nsetFormatter(callback)\n\n\nSource:\n \nlib/Console/Output.js (Lines 84-86)\n\n\nAllows to set a output message formatter callback.\n\n\n\n\nsetFormatter(callback: \nFunction\n)\n\n\n\nParameters\n\n\ncallback\n (\nFunction\n)\n\n\n\n\n\n\n\n\nwrite(string, verbosity = this.constructor.VERBOSITY_DEFAULT, args?)\n\n\nSource:\n \nlib/Console/Output.js (Lines 99-108)\n\n\nWrites text to the output buffer. Everything passed to \nwrite\n is being appended to the\ncurrent line, until a newline character (\n\\n\n) is encountered which will terminate the\ncurrent line and start a new one. If multiple newline-separated lines are passed, all lines\nwill be appended individually.\n\nTo create individual new lines, use the \nwriteLn\n method.\n\n\n\n\nwrite(string: \nString\n, verbosity: \nNumber\n?, args: any?)\n\n\n\nParameters\n\n\nstring\n (\nString\n = \n)\n\n\n\n\nString to write to the buffer\n\n\n\n\nverbosity\n (\nNumber\n? = this.constructor.VERBOSITY_DEFAULT)\n\n\n\n\nargs\n (any?)\n\n\n\n\nFormatting arguments\n\n\n\n\n\n\n\n\nwriteLn(line, verbosity = this.constructor.VERBOSITY_DEFAULT, args?)\n\n\nSource:\n \nlib/Console/Output.js (Lines 118-120)\n\n\nWrites a line to the output buffer. Lines can be formatted by passing a list of arguments,\neither as a single object (for named replacements) or multiple values (for indexed replacements).\n\n\n\n\nwriteLn(line: \nString\n, verbosity: \nNumber\n?, args: any?)\n\n\n\nParameters\n\n\nline\n (\nString\n)\n\n\n\n\nverbosity\n (\nNumber\n? = this.constructor.VERBOSITY_DEFAULT)\n\n\n\n\nargs\n (any?)\n\n\n\n\n\n\n\n\nflush()\n\n\nSource:\n \nlib/Console/Output.js (Lines 125-130)\n\n\nFlushes the output buffer by writing its content to the transport.\n\n\n\n\nflush()\n\n\n\n\n\n\n\n_writeStream(message, verbosity)\n\n\nSource:\n \nlib/Console/Output.js (Lines 138-152)\n\n\nWrites all messages to the output.\n\n\n\n\n_writeStream(message: \nString\n, verbosity: \nNumber\n)\n\n\n\nParameters\n\n\nmessage\n (\nString\n)\n\n\n\n\nverbosity\n (\nNumber\n = this.constructor.VERBOSITY_DEFAULT)", 
            "title": "Output"
        }, 
        {
            "location": "/api/Output/#console-output", 
            "text": "The  Output  class is responsible for buffering the console output.   \nnew Output(outputStream: WritableStream, verbosity:  Number ?, formatter:  Function ?)", 
            "title": "Console output"
        }, 
        {
            "location": "/api/Output/#parameters", 
            "text": "outputStream  (WritableStream)   verbosity  ( Number ? = this.constructor.VERBOSITY_DEFAULT)   formatter  ( Function ? = this.constructor._DEFAULT_FORMATTER)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Output/#instance-members", 
            "text": "verbosity  Source:   lib/Console/Output.js (Lines 52-52)  Holds the output verbosity   verbosity    setFormatter(callback)  Source:   lib/Console/Output.js (Lines 84-86)  Allows to set a output message formatter callback.   setFormatter(callback:  Function )", 
            "title": "Instance Members"
        }, 
        {
            "location": "/api/Output/#parameters_1", 
            "text": "callback  ( Function )     write(string, verbosity = this.constructor.VERBOSITY_DEFAULT, args?)  Source:   lib/Console/Output.js (Lines 99-108)  Writes text to the output buffer. Everything passed to  write  is being appended to the\ncurrent line, until a newline character ( \\n ) is encountered which will terminate the\ncurrent line and start a new one. If multiple newline-separated lines are passed, all lines\nwill be appended individually. \nTo create individual new lines, use the  writeLn  method.   write(string:  String , verbosity:  Number ?, args: any?)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Output/#parameters_2", 
            "text": "string  ( String  =  )   String to write to the buffer   verbosity  ( Number ? = this.constructor.VERBOSITY_DEFAULT)   args  (any?)   Formatting arguments     writeLn(line, verbosity = this.constructor.VERBOSITY_DEFAULT, args?)  Source:   lib/Console/Output.js (Lines 118-120)  Writes a line to the output buffer. Lines can be formatted by passing a list of arguments,\neither as a single object (for named replacements) or multiple values (for indexed replacements).   writeLn(line:  String , verbosity:  Number ?, args: any?)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Output/#parameters_3", 
            "text": "line  ( String )   verbosity  ( Number ? = this.constructor.VERBOSITY_DEFAULT)   args  (any?)     flush()  Source:   lib/Console/Output.js (Lines 125-130)  Flushes the output buffer by writing its content to the transport.   flush()    _writeStream(message, verbosity)  Source:   lib/Console/Output.js (Lines 138-152)  Writes all messages to the output.   _writeStream(message:  String , verbosity:  Number )", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Output/#parameters_4", 
            "text": "message  ( String )   verbosity  ( Number  = this.constructor.VERBOSITY_DEFAULT)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Plugin/", 
            "text": "Source:\n \nlib/Plugins/Plugin.js\n\n\n\n\n\nnew Plugin(journeyman: \nJourneyMan\n)\n\n\n\nParameters\n\n\njourneyman\n (\nJourneyMan\n)\n\n\n\n\nStatic Members\n\n\n\n\n$name\n\n\nSource:\n \nlib/Plugins/Plugin.js (Lines 22-24)\n\n\nHolds the plugin's subcommand name.\n\n\n\n\n$name\n\n\n\nReturns\n\n\nString\n\n\n\n\n\n\ncommands\n\n\nSource:\n \nlib/Plugins/Plugin.js (Lines 31-33)\n\n\nHolds all Command instances the plugin uses.\n\n\n\n\ncommands\n\n\n\nReturns\n\n\nArray\nCommand\n\n\n\n\nInstance Members\n\n\n\n\n$run(command, context)\n\n\nSource:\n \nlib/Plugins/Plugin.js (Lines 52-103)\n\n\nRuns a command on this plugin. Journeyman has figured out that this plugin is\nrequired to carry out the command, so let's find a handler and try to execute it.\n\n\n\n\n$run(command: \nString\n, context: {input: \nInput\n, output: \nOutput\n}): \nPromise\nString\n>\n\n\n\nParameters\n\n\ncommand\n (\nString\n)\n\n\n\n\nName of the command requested to run\n\n\n\n\ncontext\n ({input: \nInput\n, output: \nOutput\n})\n\n\n\n\nApplication context for the command handler\n\n\n\n\nReturns\n\n\nPromise\nString", 
            "title": "Plugin"
        }, 
        {
            "location": "/api/Plugin/#parameters", 
            "text": "journeyman  ( JourneyMan )", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Plugin/#static-members", 
            "text": "$name  Source:   lib/Plugins/Plugin.js (Lines 22-24)  Holds the plugin's subcommand name.   $name", 
            "title": "Static Members"
        }, 
        {
            "location": "/api/Plugin/#returns", 
            "text": "String    commands  Source:   lib/Plugins/Plugin.js (Lines 31-33)  Holds all Command instances the plugin uses.   commands", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Plugin/#returns_1", 
            "text": "Array Command", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Plugin/#instance-members", 
            "text": "$run(command, context)  Source:   lib/Plugins/Plugin.js (Lines 52-103)  Runs a command on this plugin. Journeyman has figured out that this plugin is\nrequired to carry out the command, so let's find a handler and try to execute it.   $run(command:  String , context: {input:  Input , output:  Output }):  Promise String >", 
            "title": "Instance Members"
        }, 
        {
            "location": "/api/Plugin/#parameters_1", 
            "text": "command  ( String )   Name of the command requested to run   context  ({input:  Input , output:  Output })   Application context for the command handler", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Plugin/#returns_2", 
            "text": "Promise String", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Schema/", 
            "text": "Source:\n \nlib/Config/Schema.js\n\n\nConfiguration Schema\n\n\nThe Schema class provides a dynamic validator for object schemas. By passing a set of rules, the\nschema can validate an entire object or single fields against these rules. This enables both\nprop checking as well as type checking.\nRule sets must be an object structured like this:\n\n\nconst\n \nrules\n \n=\n \n{\n\n\n  \n// All keys must be named like the fields to validate, so this rule for example would match\n\n  \n// a field called \nfieldName\n.\n\n  \nfieldName\n:\n \n{\n \n// All rules for \nfieldName\n will be contained within this object.\n\n\n    \n// The mandatory type rule allows to check the field against a type constructor\n\n    \ntype\n:\n \nString\n,\n \n// Or any other valid constructor like Boolean, Array, Number, etc.\n\n                  \n// You can also pass an arbitrary prototype the field will be checked\n\n                  \n// against using instanceof.\n\n\n    \n// Whether the field is required (eg. must be present).\n\n    \nrequired\n:\n \nfalse\n,\n \n// Or true - no default required in that case.\n\n\n    \n// If required is set to false, pass a default value here.\n\n    \ndefault\n:\n \nfoo\n,\n \n// Defaults will be returned if the field is undefined.\n\n\n    \n// Validators allow for custom field validations. They will only run if the type check\n\n    \n// matches, so remember to take care of both.\n\n    \n// Validator callbacks must be synchronous functions that return a boolean.\n\n    \nvalidator\n(\nvalue\n)\n \n{\n\n      \nreturn\n \n[\n \nfoo\n,\n \nbar\n,\n \nbaz\n \n].\nincludes\n(\n \nvalue\n \n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\nAfter setting up the rules, you can use two validation methods:\n\n\n\n\n\n\nschema.validate( myDataObject: Object ): Object\n\n    Validates each property of the object, that is: It runs \nvalidateField\n on each of them. If\n    the object is invalid, one of the checks will throw (so remember to try-catch), if it is\n    valid, it will return the passed object with any eventually missing fields monkey-patched to\n    their defaults, if their rules provide one.\n\n\n\n\n\n\nschema.validateField( key: String, value: Any ): Any\n\n    Validates a single field by rule name. The \nkey\n parameter will be used to check the \nvalue\n\n    against the appropriate rule. If the value is invalid, one of the checks will throw (when\n    using the \nvalidate\n method, this is what bubbles up), if it is valid, the value will be\n    returned. If there was no value and the field was optional, the default will be returned if\n    it is available.\n\n\n\n\n\n\n\n\n\nnew Schema(rules: \nObject\n)\n\n\n\nParameters\n\n\nrules\n (\nObject\n)\n\n\n\n\nA set of rules to create the schema for.\n\n\n\n\nInstance Members\n\n\n\n\nrules\n\n\nSource:\n \nlib/Config/Schema.js (Lines 87-87)\n\n\nHolds the rules the schema describes. Each rule consists of the\nfollowing properties:\n\n\n\n\ntype\n:\n \nFunction\n:\n Any other valid constructor like Boolean, Array, Number, etc.\n                          You can also pass an arbitrary prototype the field will be\n                          checked against using instanceof.\n    The mandatory type rule allows to check the field against a type constructor.\n\n\nrequired\n:\n \nBoolean\n:\n Whether the field is required (eg. must be present).\n\n\ndefault\n:\n \nAny\n:\n If required is set to false, pass a default value here.\n                        Defaults will be returned if the field is \nundefined\n.\n\n\nvalidator\n:\n \nfunction\n(\nAny\n):\n \nAny\n:\n Validators allow for custom field validations.\n                                         They will only run if the type check\n                                         matches, so remember to take care of both.\n                                         Validator callbacks must be synchronous\n                                         functions that return a boolean.\n\n\n\n\n\n\nrules\n\n\n\n\n\n\n\ntoJSON()\n\n\nSource:\n \nlib/Config/Schema.js (Lines 95-103)\n\n\nCreates an empty, default schema holding all defaults.\n\n\n\n\ntoJSON(): \nObject\n\n\n\nReturns\n\n\nObject\n\n\n\n\n\n\nvalidate(obj?)\n\n\nSource:\n \nlib/Config/Schema.js (Lines 124-157)\n\n\nConfiguration object validation\n\n\nValidates a given object against the schema. This works by running each field through\n\nvalidateField\n individually. If a field is missing but defined in the schema, and that\nfield is flagged as required, it will throw, otherwise it will be set to it's default\nvalue and further checking is omitted (since defaults are inherently trusted).\n\n\n\n\nvalidate(obj: \nObject\n?): \nObject\n\n\n\nParameters\n\n\nobj\n (\nObject\n?)\n\n\n\n\nObject to validate. This will probably be the data read from the config                        file.\n\n\n\n\nReturns\n\n\nObject\n\n\nThrows\n\n\n\n\n\n\nConfigValidationError: If an invalid (non-object) parameter has been passed\n\n\n\n\n\n\nConfigValidationMissingFieldError: If a required field is missing\n\n\n\n\n\n\nConfigValidationInvalidFieldError: If a field is unknown\n\n\n\n\n\n\nConfigValidationTypeError: If a values type doesn't match the requirements\n\n\n\n\n\n\nConfigValidationValidatorError: If a field validator can't validate a field\n\n\n\n\n\n\n\n\n\n\nvalidateField(field, value)\n\n\nSource:\n \nlib/Config/Schema.js (Lines 188-264)\n\n\nValidates a single field.\nThe validation process is split into several checks, ordered by probability of them occurring.\nEach check will throw a specific error if it fails.\n\n\n\n\nCheck if a rule for the field is available\n\n\n\n\nCheck if the type matches the rule. This is a bit of work since there is a specific\n    check for each type:\n\n\n\n\nString\n - checked using \ntypeof\n\n\nNumber\n - checked using \ntypeof\n and \nisNaN\n\n\nBoolean\n - checked using \ntypeof\n\n\nArray\n - checked using \nArray.isArray\n\n\nSymbol\n - checked using \ntypeof\n\n\nObject\n -  checked using \ntypeof\n, then \nArray.isArray\n and a \nnull\n check.\n    The object will then be merged with the rule's default, if any.\n\n\nAnything else\n - checked using \ninstanceof\n\n\n\n\n\n\n\n\nCheck if the validator callback (if any) can validate the field (returns \ntrue\n)\n\n\n\n\n\n\nIf all these checks pass, the value will be returned.\n\n\n\n\nvalidateField(field: \nString\n, value: any): any\n\n\n\nParameters\n\n\nfield\n (\nString\n)\n\n\n\n\nName of the field to validate\n\n\n\n\nvalue\n (any)\n\n\n\n\nField value\n\n\n\n\nReturns\n\n\nany\n\n\nThrows\n\n\n\n\n\n\nConfigValidationInvalidFieldError: If the field is unknown\n\n\n\n\n\n\nConfigValidationTypeError: If the values type doesn't match the requirements\n\n\n\n\n\n\nConfigValidationValidatorError: If the field validator can't validate the field", 
            "title": "Schema"
        }, 
        {
            "location": "/api/Schema/#configuration-schema", 
            "text": "The Schema class provides a dynamic validator for object schemas. By passing a set of rules, the\nschema can validate an entire object or single fields against these rules. This enables both\nprop checking as well as type checking.\nRule sets must be an object structured like this:  const   rules   =   { \n\n   // All keys must be named like the fields to validate, so this rule for example would match \n   // a field called  fieldName . \n   fieldName :   {   // All rules for  fieldName  will be contained within this object. \n\n     // The mandatory type rule allows to check the field against a type constructor \n     type :   String ,   // Or any other valid constructor like Boolean, Array, Number, etc. \n                   // You can also pass an arbitrary prototype the field will be checked \n                   // against using instanceof. \n\n     // Whether the field is required (eg. must be present). \n     required :   false ,   // Or true - no default required in that case. \n\n     // If required is set to false, pass a default value here. \n     default :   foo ,   // Defaults will be returned if the field is undefined. \n\n     // Validators allow for custom field validations. They will only run if the type check \n     // matches, so remember to take care of both. \n     // Validator callbacks must be synchronous functions that return a boolean. \n     validator ( value )   { \n       return   [   foo ,   bar ,   baz   ]. includes (   value   ); \n     } \n   }  }   After setting up the rules, you can use two validation methods:    schema.validate( myDataObject: Object ): Object \n    Validates each property of the object, that is: It runs  validateField  on each of them. If\n    the object is invalid, one of the checks will throw (so remember to try-catch), if it is\n    valid, it will return the passed object with any eventually missing fields monkey-patched to\n    their defaults, if their rules provide one.    schema.validateField( key: String, value: Any ): Any \n    Validates a single field by rule name. The  key  parameter will be used to check the  value \n    against the appropriate rule. If the value is invalid, one of the checks will throw (when\n    using the  validate  method, this is what bubbles up), if it is valid, the value will be\n    returned. If there was no value and the field was optional, the default will be returned if\n    it is available.     \nnew Schema(rules:  Object )", 
            "title": "Configuration Schema"
        }, 
        {
            "location": "/api/Schema/#parameters", 
            "text": "rules  ( Object )   A set of rules to create the schema for.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Schema/#instance-members", 
            "text": "rules  Source:   lib/Config/Schema.js (Lines 87-87)  Holds the rules the schema describes. Each rule consists of the\nfollowing properties:   type :   Function :  Any other valid constructor like Boolean, Array, Number, etc.\n                          You can also pass an arbitrary prototype the field will be\n                          checked against using instanceof.\n    The mandatory type rule allows to check the field against a type constructor.  required :   Boolean :  Whether the field is required (eg. must be present).  default :   Any :  If required is set to false, pass a default value here.\n                        Defaults will be returned if the field is  undefined .  validator :   function ( Any ):   Any :  Validators allow for custom field validations.\n                                         They will only run if the type check\n                                         matches, so remember to take care of both.\n                                         Validator callbacks must be synchronous\n                                         functions that return a boolean.    rules    toJSON()  Source:   lib/Config/Schema.js (Lines 95-103)  Creates an empty, default schema holding all defaults.   toJSON():  Object", 
            "title": "Instance Members"
        }, 
        {
            "location": "/api/Schema/#returns", 
            "text": "Object    validate(obj?)  Source:   lib/Config/Schema.js (Lines 124-157)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Schema/#configuration-object-validation", 
            "text": "Validates a given object against the schema. This works by running each field through validateField  individually. If a field is missing but defined in the schema, and that\nfield is flagged as required, it will throw, otherwise it will be set to it's default\nvalue and further checking is omitted (since defaults are inherently trusted).   validate(obj:  Object ?):  Object", 
            "title": "Configuration object validation"
        }, 
        {
            "location": "/api/Schema/#parameters_1", 
            "text": "obj  ( Object ?)   Object to validate. This will probably be the data read from the config                        file.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Schema/#returns_1", 
            "text": "Object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Schema/#throws", 
            "text": "ConfigValidationError: If an invalid (non-object) parameter has been passed    ConfigValidationMissingFieldError: If a required field is missing    ConfigValidationInvalidFieldError: If a field is unknown    ConfigValidationTypeError: If a values type doesn't match the requirements    ConfigValidationValidatorError: If a field validator can't validate a field      validateField(field, value)  Source:   lib/Config/Schema.js (Lines 188-264)  Validates a single field.\nThe validation process is split into several checks, ordered by probability of them occurring.\nEach check will throw a specific error if it fails.   Check if a rule for the field is available   Check if the type matches the rule. This is a bit of work since there is a specific\n    check for each type:   String  - checked using  typeof  Number  - checked using  typeof  and  isNaN  Boolean  - checked using  typeof  Array  - checked using  Array.isArray  Symbol  - checked using  typeof  Object  -  checked using  typeof , then  Array.isArray  and a  null  check.\n    The object will then be merged with the rule's default, if any.  Anything else  - checked using  instanceof     Check if the validator callback (if any) can validate the field (returns  true )    If all these checks pass, the value will be returned.   validateField(field:  String , value: any): any", 
            "title": "Throws"
        }, 
        {
            "location": "/api/Schema/#parameters_2", 
            "text": "field  ( String )   Name of the field to validate   value  (any)   Field value", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/Schema/#returns_2", 
            "text": "any", 
            "title": "Returns"
        }, 
        {
            "location": "/api/Schema/#throws_1", 
            "text": "ConfigValidationInvalidFieldError: If the field is unknown    ConfigValidationTypeError: If the values type doesn't match the requirements    ConfigValidationValidatorError: If the field validator can't validate the field", 
            "title": "Throws"
        }
    ]
}